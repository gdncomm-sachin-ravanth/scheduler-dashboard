<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAI Scheduler Management Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìä</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #4f46e5;
            --primary-dark: #4338ca;
            --primary-light: #818cf8;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #3b82f6;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            --sidebar-width: 260px;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--gray-50);
            color: var(--gray-900);
            line-height: 1.5;
        }
        
        /* Layout */
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: white;
            border-right: 1px solid var(--gray-200);
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 8px rgba(0,0,0,0.05);
        }
        
        .sidebar-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .sidebar-header h1 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--gray-900);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .sidebar-nav {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
        }
        
        .nav-section {
            margin-bottom: 1.5rem;
        }
        
        .nav-section-title {
            padding: 0.5rem 1.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--gray-600);
            letter-spacing: 0.5px;
        }
        
        .nav-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1.5rem;
            color: var(--gray-700);
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .nav-item:hover {
            background: var(--gray-50);
            color: var(--primary);
        }
        
        .nav-item.active {
            background: #eef2ff;
            color: var(--primary);
            border-left-color: var(--primary);
        }
        
        .nav-icon {
            font-size: 1.1rem;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .top-bar {
            background: white;
            border-bottom: 1px solid var(--gray-200);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .top-bar h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gray-900);
        }
        
        .top-bar-meta {
            font-size: 0.875rem;
            color: var(--gray-600);
        }
        
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .page-section {
            display: none;
        }
        
        .page-section.active {
            display: block;
        }
        
        /* Stats Cards */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .stat-card {
            background: white;
            padding: 1.25rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border-left: 3px solid var(--primary);
            transition: all 0.2s ease;
        }
        
        .stat-card.clickable {
            cursor: pointer;
        }
        
        .stat-card.clickable:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.15);
        }
        
        .stat-card.clickable.active {
            background: var(--gray-50);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .stat-card.success { border-left-color: var(--success); }
        .stat-card.danger { border-left-color: var(--danger); }
        .stat-card.warning { border-left-color: var(--warning); }
        .stat-card.info { border-left-color: var(--info); }
        
        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--gray-600);
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--gray-900);
            margin-top: 0.25rem;
        }
        
        /* Filters */
        .filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(226, 232, 240, 0.8);
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .filter-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--gray-600);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin: 0;
        }
        
        .filter-group label .filter-icon {
            font-size: 1rem;
            opacity: 0.8;
        }
        
        .filter-group input,
        .filter-group select {
            width: 100%;
            padding: 0.625rem 0.875rem;
            border: 2px solid var(--gray-200);
            border-radius: 0.5rem;
            font-size: 0.875rem;
            background: white;
            color: var(--gray-900);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        
        .filter-group input::placeholder {
            color: var(--gray-400);
        }
        
        .filter-group input:focus,
        .filter-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transform: translateY(-1px);
        }
        
        .filter-group select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            padding-right: 2.5rem;
        }
        
        .filter-group select:hover {
            border-color: var(--gray-300);
        }
        
        .filter-group input:hover {
            border-color: var(--gray-300);
        }
        
        /* Search box with clear button */
        .search-wrapper {
            position: relative;
            width: 100%;
        }
        
        .search-wrapper input {
            padding-right: 2.5rem;
        }
        
        .search-clear-btn {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--gray-400);
            transition: color 0.2s, opacity 0.2s;
            font-size: 1.25rem;
            line-height: 1;
            width: 1.5rem;
            height: 1.5rem;
            opacity: 0;
            pointer-events: none;
            border-radius: 50%;
        }
        
        .search-clear-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .search-wrapper:has(input:not(:placeholder-shown)) .search-clear-btn,
        .search-wrapper input:focus ~ .search-clear-btn {
            opacity: 1;
            pointer-events: auto;
        }
        
        .search-clear-btn:hover {
            color: var(--gray-600);
        }
        
        .search-clear-btn:active {
            color: var(--gray-800);
        }
        
        
        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--primary-dark);
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-success:hover {
            background: #059669;
        }
        
        .btn-sm {
            padding: 0.375rem 0.75rem;
            font-size: 0.8125rem;
        }
        
        /* Refresh Button Styles */
        #refreshDataBtn {
            background: linear-gradient(135deg, var(--primary) 0%, #6366f1 100%);
            color: white;
            border: none;
            border-radius: 0.5rem;
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 2px 4px rgba(79, 70, 229, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        #refreshDataBtn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        #refreshDataBtn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        #refreshDataBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
            background: linear-gradient(135deg, var(--primary-dark) 0%, #5b5ff0 100%);
        }
        
        #refreshDataBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(79, 70, 229, 0.2);
        }
        
        #refreshDataBtn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }
        
        #refreshIcon {
            font-size: 1rem;
            transition: transform 0.3s ease;
            display: inline-block;
        }
        
        #refreshDataBtn:hover:not(:disabled) #refreshIcon {
            transform: rotate(180deg);
        }
        
        #refreshDataBtn:disabled #refreshIcon {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        #refreshText {
            position: relative;
            z-index: 1;
        }
        
        /* Toast Notification Styles */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            pointer-events: none;
        }
        
        .toast {
            background: white;
            border-radius: 0.5rem;
            padding: 1rem 1.25rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            min-width: 300px;
            max-width: 400px;
            pointer-events: auto;
            animation: slideInRight 0.3s ease-out;
            border-left: 4px solid var(--success);
        }
        
        .toast.error {
            border-left-color: var(--danger);
        }
        
        .toast.warning {
            border-left-color: var(--warning);
        }
        
        .toast.info {
            border-left-color: var(--info);
        }
        
        .toast-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }
        
        .toast-content {
            flex: 1;
        }
        
        .toast-title {
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--gray-900);
            margin-bottom: 0.25rem;
        }
        
        .toast-message {
            font-size: 0.8125rem;
            color: var(--gray-600);
        }
        
        .toast-close {
            background: none;
            border: none;
            font-size: 1.25rem;
            color: var(--gray-400);
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: color 0.2s;
        }
        
        .toast-close:hover {
            color: var(--gray-600);
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .toast.hiding {
            animation: slideOutRight 0.3s ease-in forwards;
        }
        
        /* Table */
        .table-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .table-wrapper {
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }
        
        thead {
            background: var(--gray-50);
            position: sticky;
            top: 0;
        }
        
        th {
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: var(--gray-700);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--gray-200);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        
        th:hover {
            background: var(--gray-100);
        }
        
        th.sortable::after {
            content: " ‚áÖ";
            opacity: 0.3;
        }
        
        th.sorted-asc::after, th.sort-asc::after {
            content: " ‚Üë";
            opacity: 1;
            color: var(--primary);
        }
        
        th.sorted-desc::after, th.sort-desc::after {
            content: " ‚Üì";
            opacity: 1;
            color: var(--primary);
        }
        
        td {
            padding: 0.75rem;
            border-bottom: 1px solid var(--gray-100);
            color: var(--gray-900);
        }
        
        tr:hover {
            background: var(--gray-50);
        }
        
        /* Badges */
        .badge {
            display: inline-block;
            padding: 0.25rem 0.625rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .badge-success, .status-enabled, .badge.success {
            background: #d1fae5;
            color: #065f46;
        }
        
        .badge-danger, .status-disabled, .badge.failed {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .badge-warning, .badge.running {
            background: #fef3c7;
            color: #92400e;
        }
        
        .badge-info, .badge.date {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .badge-daily, .frequency-daily {
            background: #d1fae5;
            color: #065f46;
        }
        
        .badge-weekly, .frequency-weekly {
            background: #fef3c7;
            color: #92400e;
        }
        
        .badge-monthly, .frequency-monthly {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .badge-secondary {
            background: #e5e7eb;
            color: #4b5563;
        }
        
        .action-btn {
            padding: 0.375rem 0.75rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
        }
        
        .action-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .action-btn:active {
            transform: translateY(0);
        }
        
        .action-btn-icon {
            padding: 0.5rem;
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
            border-radius: 0.375rem;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }
        
        .action-btn-icon:hover {
            background: var(--primary);
            color: white;
            transform: scale(1.1);
        }
        
        .action-btn-icon:active {
            transform: scale(0.95);
        }
        
        .clickable-analytic-name {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .clickable-analytic-name:hover {
            opacity: 0.8;
            text-decoration: underline;
        }
        
        .clickable-analytic-name-bq {
            cursor: pointer;
            color: var(--primary);
            text-decoration: underline;
            transition: all 0.2s;
        }
        
        .clickable-analytic-name-bq:hover {
            opacity: 0.8;
            color: var(--primary);
        }
        
        .toggle-switch {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .toggle-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--gray-700);
        }
        
        .toggle-buttons {
            display: inline-flex;
            border: 1px solid var(--gray-300);
            border-radius: 0.375rem;
            overflow: hidden;
        }
        
        .toggle-btn {
            padding: 0.5rem 1rem;
            border: none;
            background: white;
            color: var(--gray-700);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border-right: 1px solid var(--gray-300);
        }
        
        .toggle-btn:last-child {
            border-right: none;
        }
        
        .toggle-btn.active {
            background: var(--primary);
            color: white;
        }
        
        .toggle-btn:hover:not(.active) {
            background: var(--gray-50);
        }
        
        .job-name {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.8125rem;
            color: var(--primary);
            font-weight: 500;
        }
        
        .schedule-time {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.8125rem;
            color: var(--success);
            font-weight: 500;
        }
        
        /* Insights Grid */
        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .insight-card {
            background: white;
            padding: 1.25rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border-left: 3px solid var(--info);
        }
        
        .insight-label {
            font-size: 0.75rem;
            color: var(--gray-600);
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .insight-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 0.5rem;
            color: var(--gray-900);
        }
        
        /* Day Breakdown */
        .day-breakdown {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .day-item {
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .day-name {
            font-weight: 600;
            color: var(--gray-900);
            min-width: 180px;
        }
        
        .day-metrics {
            display: flex;
            gap: 1.5rem;
        }
        
        .day-metric {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }
        
        .day-metric-label {
            font-size: 0.75rem;
            color: var(--gray-600);
            text-transform: uppercase;
        }
        
        .day-metric-value {
            font-size: 1.25rem;
            font-weight: 700;
        }
        
        .day-metric.total .day-metric-value { color: var(--info); }
        .day-metric.success .day-metric-value { color: var(--success); }
        .day-metric.failed .day-metric-value { color: var(--danger); }
        
        /* Performance Cards */
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
        }
        
        .performance-card {
            background: white;
            padding: 1.25rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .performance-card h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--gray-900);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .perf-item {
            display: flex;
            justify-content: space-between;
            padding: 0.625rem 0;
            border-bottom: 1px solid var(--gray-100);
        }
        
        .perf-item:last-child {
            border-bottom: none;
        }
        
        .perf-item-name {
            font-weight: 500;
            color: var(--gray-900);
            font-size: 0.875rem;
        }
        
        .perf-item-value {
            font-weight: 600;
            color: var(--primary);
            font-size: 0.875rem;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        .modal-content {
            background: white;
            margin: 3% auto;
            padding: 0;
            border-radius: 0.75rem;
            max-width: 800px;
            max-height: 90vh;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        #bqDetailsModal .modal-content {
            max-height: 95vh;
        }
        
        #bqDetailsModal .modal-body {
            max-height: calc(95vh - 120px);
        }
        
        .modal-header {
            background: var(--gray-50);
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--gray-200);
            border-radius: 0.75rem 0.75rem 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--gray-900);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .modal-header h3 span {
            font-weight: 500;
            color: var(--gray-700);
        }
        
        .close {
            font-size: 1.5rem;
            font-weight: 300;
            color: var(--gray-600);
            cursor: pointer;
            transition: color 0.2s;
            border: none;
            background: none;
        }
        
        .close:hover {
            color: var(--gray-900);
        }
        
        .modal-body {
            padding: 1.5rem;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .modal-body pre {
            background: var(--gray-50);
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.8125rem;
            border: 1px solid var(--gray-200);
            margin: 1rem 0;
        }
        
        #schedulerRunsModalContent table tbody tr:hover {
            background-color: var(--gray-50);
            cursor: pointer;
        }
        
        #schedulerRunsModalContent table tbody tr {
            transition: background-color 0.2s ease;
        }
        
        #schedulerRunsModalContent table thead {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .curl-command {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.75rem;
            color: var(--gray-600);
            max-width: 300px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            padding: 0.375rem 0.625rem;
            background: var(--gray-50);
            border-radius: 0.25rem;
            border: 1px solid var(--gray-200);
            transition: all 0.2s;
        }
        
        .curl-command:hover {
            background: var(--gray-100);
            border-color: var(--gray-300);
        }
        
        .no-results {
            text-align: center;
            padding: 3rem;
            color: var(--gray-600);
        }
        
        /* Today's Report Styles */
        .chart-container {
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }
        
        .chart-title {
            font-weight: 700;
            font-size: 1.125rem;
            margin-bottom: 0.75rem;
            color: var(--gray-900);
        }
        
        /* Heatmap Styles */
        .heatmap-container {
            overflow-x: auto;
            overflow-y: auto;
            max-height: calc(100vh - 400px);
            margin: 1rem 0;
            position: relative;
        }
        
        .heatmap-grid {
            display: grid;
            gap: 2px;
            min-width: 800px;
        }
        
        .heatmap-row {
            display: grid;
            grid-template-columns: 200px repeat(24, 1fr);
            gap: 2px;
        }
        
        .heatmap-row-header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: white;
        }
        
        .heatmap-label {
            padding: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            background: var(--gray-50);
            border-radius: 0.25rem;
        }
        
        .heatmap-row-header .heatmap-label {
            background: linear-gradient(135deg, var(--gray-50) 0%, var(--gray-100) 100%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .heatmap-cell {
            padding: 0.5rem;
            text-align: center;
            font-size: 0.7rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: transform 0.2s;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .heatmap-cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        
        .heatmap-cell.empty {
            background: var(--gray-100);
        }
        
        /* Timeline Styles */
        .timeline-container {
            position: relative;
            padding: 2rem 0;
            background: white;
            border-radius: 0.5rem;
        }
        
        .timeline-hours {
            display: grid;
            grid-template-columns: repeat(24, 1fr);
            border-bottom: 2px solid var(--gray-300);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .timeline-hour {
            text-align: center;
            font-size: 0.7rem;
            color: var(--gray-600);
            font-weight: 600;
        }
        
        .timeline-row {
            position: relative;
            height: 40px;
            margin-bottom: 0.5rem;
            background: var(--gray-50);
            border-radius: 0.25rem;
            border-left: 3px solid var(--primary);
        }
        
        .timeline-label {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 200px;
            padding: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            background: white;
            z-index: 2;
            border-right: 1px solid var(--gray-300);
        }
        
        .timeline-track {
            position: absolute;
            left: 200px;
            right: 0;
            top: 0;
            bottom: 0;
            display: grid;
            grid-template-columns: repeat(24, 1fr);
        }
        
        .timeline-event {
            position: absolute;
            height: 80%;
            top: 10%;
            border-radius: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .timeline-event:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .timeline-event.success {
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
        }
        
        .timeline-event.failed {
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
        }
        
        .timeline-event.retry {
            background: linear-gradient(135deg, var(--warning) 0%, #d97706 100%);
        }
        
        .timeline-event.pending {
            background: linear-gradient(135deg, var(--gray-300) 0%, var(--gray-400) 100%);
            color: var(--gray-600);
            border: 1px dashed var(--gray-400);
        }
        
        .legend-toggle {
            font-size: 0.875rem;
            color: var(--primary);
            cursor: pointer;
            user-select: none;
            margin-bottom: 0.75rem;
            display: inline-block;
            padding: 0.375rem 0.75rem;
            border-radius: 0.375rem;
            transition: background 0.2s;
        }
        
        .legend-toggle:hover {
            background: var(--gray-100);
        }
        
        .job-names {
            margin-top: 1rem;
            font-size: 0.875rem;
            color: var(--gray-900);
            max-height: 150px;
            overflow-y: auto;
            background: var(--gray-50);
            border-radius: 0.5rem;
            padding: 0.75rem;
            line-height: 1.4;
            white-space: pre-line;
            word-break: break-word;
            border: 1px solid var(--gray-200);
        }
        
        .status-success {
            color: var(--success);
            font-weight: 700;
        }
        
        .status-fail {
            color: var(--danger);
            font-weight: 700;
        }
        
        .status-pending {
            color: var(--warning);
            font-weight: 700;
        }
        
        .status-in-progress {
            color: var(--info);
            font-weight: 700;
        }
        
        .data-mismatch {
            background-color: #fff3cd !important;
        }
        
        .data-mismatch:hover {
            background-color: #ffe69c !important;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: -260px;
                z-index: 100;
                transition: left 0.3s;
            }
            
            .sidebar.open {
                left: 0;
            }
            
            .stats {
                grid-template-columns: 1fr;
            }
            
            .filters {
                grid-template-columns: 1fr;
                padding: 1rem;
                gap: 0.875rem;
            }
            
            .filter-group {
                min-width: 100%;
            }
            
            .filter-group {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>
                    <span>üìä</span>
                    SAI Scheduler Dashboard
                </h1>
            </div>
            
            <nav class="sidebar-nav">
                <div class="nav-section">
                    <div class="nav-section-title">Rundeck Jobs</div>
                    <div class="nav-item" onclick="navigateTo('jobs')">
                        <span class="nav-icon">üöÄ</span>
                        <span>All Jobs</span>
                    </div>
                </div>
                
                <div class="nav-section">
                    <div class="nav-section-title">Today's Report</div>
                    <div class="nav-item active" onclick="navigateTo('today-report')">
                        <span class="nav-icon">üìä</span>
                        <span>Today's Summary</span>
                    </div>
                </div>
                
                <div class="nav-section">
                    <div class="nav-section-title">Scheduler Reports</div>
                    <div class="nav-item" onclick="navigateTo('reports-overview')">
                        <span class="nav-icon">üìà</span>
                        <span>Overview</span>
                    </div>
                    <div class="nav-item" onclick="navigateTo('reports-patterns')">
                        <span class="nav-icon">üîç</span>
                        <span>Pattern Analysis</span>
                    </div>
                    <div class="nav-item" onclick="navigateTo('reports-data')">
                        <span class="nav-icon">üìã</span>
                        <span>All Data</span>
                    </div>
                </div>
            </nav>
        </aside>
        
        <!-- Main Content -->
        <main class="main-content">
            <div class="top-bar">
                <h2 id="pageTitle">Today's Report</h2>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <div id="refreshButtonContainer" style="display: none; align-items: center; gap: 1rem;">
                        <button id="refreshDataBtn" onclick="refreshData()" 
                                style="display: none;">
                            <span id="refreshIcon">üîÑ</span>
                            <span id="refreshText">Refresh today data</span>
                        </button>
                        <span id="lastUpdatedTime" style="display: none; font-size: 0.875rem; color: var(--gray-600); font-style: italic; padding-left: 0.5rem; border-left: 1px solid var(--gray-300);"></span>
                    </div>
                </div>
            </div>
            
            <!-- Shared Reports Header (visible on Reports Overview, Pattern Analysis, and All Scheduler Data pages) -->
            <div id="reportsHeader" style="display: none; margin-bottom: 1.5rem; padding: 1rem; background: white; border-radius: 0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: nowrap; overflow-x: auto;">
                    <label for="pastDataFilter" style="font-weight: 600; color: var(--gray-700); font-size: 0.875rem; white-space: nowrap;">
                        üìÖ Date Range Filter:
                    </label>
                    <select id="pastDataFilter" onchange="filterPastData()" 
                            style="padding: 0.5rem 0.75rem; border: 1px solid var(--gray-300); border-radius: 0.375rem; 
                            font-size: 0.875rem; background: white; min-width: 180px; cursor: pointer; flex-shrink: 0;">
                        <option value="YESTERDAY" selected>YESTERDAY</option>
                        <option value="LAST_7_DAYS">LAST 7 DAYS</option>
                        <option value="LAST_14_DAYS">LAST 14 DAYS</option>
                    </select>
                    <button id="refreshPastDataBtn" onclick="refreshPastData()" 
                            style="padding: 0.5rem 1rem; border: 1px solid var(--gray-300); border-radius: 0.375rem; 
                            background: var(--primary); color: white; cursor: pointer; font-size: 0.875rem; font-weight: 500;
                            display: flex; align-items: center; gap: 0.5rem; white-space: nowrap; flex-shrink: 0;">
                        <span id="refreshPastDataIcon">üîÑ</span>
                        <span id="refreshPastDataText">Refresh</span>
                    </button>
                    <span id="pastDataLastUpdatedTime" style="font-size: 0.875rem; color: var(--gray-600); font-style: italic; padding-left: 0.5rem; border-left: 1px solid var(--gray-300); white-space: nowrap; flex-shrink: 0;"></span>
                    <span id="pastDataStatus" style="font-size: 0.875rem; color: var(--gray-600); white-space: nowrap; flex-shrink: 0;"></span>
                </div>
            </div>
            
            <div class="content-area">
                <!-- Rundeck Jobs Section -->
                <section id="jobs-section" class="page-section">
                    <!-- Compact Metrics -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 0.75rem; margin-bottom: 1rem;">
                        <div class="stat-card info" style="padding: 0.75rem 1rem; border-left-width: 3px;">
                            <div class="stat-label" style="font-size: 0.7rem;">üìä Total Jobs</div>
                            <div class="stat-value" style="font-size: 1.5rem; margin-top: 0.125rem;" id="totalJobs">0</div>
                        </div>
                        <div class="stat-card success" style="padding: 0.75rem 1rem; border-left-width: 3px;">
                            <div class="stat-label" style="font-size: 0.7rem;">‚úÖ Enabled</div>
                            <div class="stat-value" style="font-size: 1.5rem; margin-top: 0.125rem;" id="enabledJobs">0</div>
                        </div>
                        <div class="stat-card warning" style="padding: 0.75rem 1rem; border-left-width: 3px; background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);">
                            <div class="stat-label" style="font-size: 0.7rem;">üü° Canary</div>
                            <div class="stat-value" style="font-size: 1.5rem; margin-top: 0.125rem; color: #92400e;" id="canaryJobs">0</div>
                        </div>
                        <div class="stat-card info" style="padding: 0.75rem 1rem; border-left-width: 3px; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);">
                            <div class="stat-label" style="font-size: 0.7rem;">üîµ Non-Canary</div>
                            <div class="stat-value" style="font-size: 1.5rem; margin-top: 0.125rem; color: #1e40af;" id="nonCanaryJobs">0</div>
                        </div>
                    </div>
                    
                    <!-- Frequency Breakdown -->
                    <div style="background: white; padding: 0.875rem 1rem; border-radius: 0.375rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
                            <div style="font-size: 0.75rem; font-weight: 600; text-transform: uppercase; color: var(--gray-600); letter-spacing: 0.5px;">
                                üìÖ Frequency (Enabled)
                            </div>
                            <div style="display: flex; gap: 1rem; flex: 1; justify-content: space-around; min-width: 300px;">
                                <div style="text-align: center; padding: 0.5rem 0.75rem; background: var(--gray-50); border-radius: 0.25rem; border-left: 3px solid #059669; flex: 1;">
                                    <div style="font-size: 0.65rem; color: var(--gray-600); margin-bottom: 0.25rem; font-weight: 600;">DAILY</div>
                                    <div style="font-size: 1.375rem; font-weight: 700; color: #059669;" id="dailyJobs">0</div>
                                </div>
                                <div style="text-align: center; padding: 0.5rem 0.75rem; background: var(--gray-50); border-radius: 0.25rem; border-left: 3px solid #d97706; flex: 1;">
                                    <div style="font-size: 0.65rem; color: var(--gray-600); margin-bottom: 0.25rem; font-weight: 600;">WEEKLY</div>
                                    <div style="font-size: 1.375rem; font-weight: 700; color: #d97706;" id="weeklyJobs">0</div>
                                </div>
                                <div style="text-align: center; padding: 0.5rem 0.75rem; background: var(--gray-50); border-radius: 0.25rem; border-left: 3px solid #1e40af; flex: 1;">
                                    <div style="font-size: 0.65rem; color: var(--gray-600); margin-bottom: 0.25rem; font-weight: 600;">MONTHLY</div>
                                    <div style="font-size: 1.375rem; font-weight: 700; color: #1e40af;" id="monthlyJobs">0</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Job Schedule Heatmap -->
                    <div class="chart-container">
                        <div class="chart-title">üî• Job Schedule Heatmap (By Hour of Day)</div>
                        
                        <!-- Filters and Legend -->
                        <div style="display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; margin-bottom: 1rem; padding: 0.75rem; background: var(--gray-50); border-radius: 0.5rem; font-size: 0.75rem;">
                            <!-- Filters -->
                            <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                                <span style="color: var(--gray-600); font-weight: 600; margin-right: 0.25rem;">Try:</span>
                                <button class="filter-btn active" id="jobs-heatmap-all-tries" onclick="filterJobsHeatmapByTry('All')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: var(--primary); color: white; cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    All
                                </button>
                                <button class="filter-btn" id="jobs-heatmap-try-1" onclick="filterJobsHeatmapByTry('1')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    1st
                                </button>
                                <button class="filter-btn" id="jobs-heatmap-try-2" onclick="filterJobsHeatmapByTry('2')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    2nd
                                </button>
                                <button class="filter-btn" id="jobs-heatmap-try-3" onclick="filterJobsHeatmapByTry('3')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    3rd
                                </button>
                                <button class="filter-btn" id="jobs-heatmap-try-4" onclick="filterJobsHeatmapByTry('4')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    4th
                                </button>
                            </div>
                            
                            <div style="width: 1px; height: 20px; background: var(--gray-300);"></div>
                            
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <span style="color: var(--gray-600); font-weight: 600; margin-right: 0.25rem;">Status:</span>
                                <button class="filter-btn" id="jobs-heatmap-status-all" onclick="filterJobsHeatmapByStatus('All')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    All
                                </button>
                                <button class="filter-btn active" id="jobs-heatmap-status-enabled" onclick="filterJobsHeatmapByStatus('Enabled')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: var(--primary); color: white; cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    ‚úì Enabled
                                </button>
                                <button class="filter-btn" id="jobs-heatmap-status-disabled" onclick="filterJobsHeatmapByStatus('Disabled')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    ‚úï Disabled
                                </button>
                            </div>
                            
                            <div style="width: 1px; height: 20px; background: var(--gray-300);"></div>
                            
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <span style="color: var(--gray-600); font-weight: 600; margin-right: 0.25rem;">Env:</span>
                                <button class="filter-btn active" id="jobs-heatmap-env-all" onclick="filterJobsHeatmapByEnvironment('All')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: var(--primary); color: white; cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    All
                                </button>
                                <button class="filter-btn" id="jobs-heatmap-env-canary" onclick="filterJobsHeatmapByEnvironment('Canary')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    üü° Canary
                                </button>
                                <button class="filter-btn" id="jobs-heatmap-env-noncanary" onclick="filterJobsHeatmapByEnvironment('Non-Canary')" 
                                        style="padding: 0.3rem 0.6rem; border: 1px solid var(--gray-300); border-radius: 0.25rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.75rem; font-weight: 500; white-space: nowrap;">
                                    üîµ Non-Canary
                                </button>
                            </div>
                            
                            <div style="width: 1px; height: 20px; background: var(--gray-300); margin-left: auto;"></div>
                            
                            <!-- Legend -->
                            <div style="display: flex; gap: 0.75rem; align-items: center; flex-wrap: wrap;">
                                <span style="color: var(--gray-600); font-weight: 600;">Legend:</span>
                                <div style="display: flex; gap: 0.3rem; align-items: center;">
                                    <div style="width: 14px; height: 14px; background: #10b981; border-radius: 0.2rem; flex-shrink: 0;"></div>
                                    <span style="white-space: nowrap;">Enabled</span>
                                </div>
                                <div style="display: flex; gap: 0.3rem; align-items: center;">
                                    <div style="width: 14px; height: 14px; background: #9ca3af; border-radius: 0.2rem; flex-shrink: 0;"></div>
                                    <span style="white-space: nowrap;">Disabled</span>
                                </div>
                                <span style="color: var(--gray-500); white-space: nowrap;">Intensity = Count</span>
                            </div>
                        </div>
                        
                        <div class="heatmap-container" id="jobsHeatmapContainer">
                            <div class="no-results">Loading heatmap...</div>
                        </div>
                    </div>
                    
                    <div class="filters">
                        <div class="filter-group">
                            <label>
                                <span class="filter-icon">üîç</span>
                                <span>Search</span>
                            </label>
                            <div class="search-wrapper">
                                <input type="text" id="jobSearch" placeholder="Search by job name...">
                                <button class="search-clear-btn" onclick="clearJobSearch()" title="Clear search">√ó</button>
                            </div>
                        </div>
                        <div class="filter-group">
                            <label>
                                <span class="filter-icon">üìÖ</span>
                                <span>Frequency</span>
                            </label>
                            <select id="frequencyFilter">
                                <option value="All">All</option>
                                <option value="Daily">Daily</option>
                                <option value="Weekly">Weekly</option>
                                <option value="Monthly">Monthly</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>
                                <span class="filter-icon">‚ö°</span>
                                <span>Status</span>
                            </label>
                            <select id="jobStatusFilter">
                                <option value="All">All</option>
                                <option value="Enabled">Enabled</option>
                                <option value="Disabled">Disabled</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>
                                <span class="filter-icon">üåê</span>
                                <span>Environment</span>
                            </label>
                            <select id="environmentFilter">
                                <option value="All">All</option>
                                <option value="Canary">üü° Canary</option>
                                <option value="Non-Canary">üîµ Non-Canary</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>
                                <span class="filter-icon">üìÅ</span>
                                <span>Tab</span>
                            </label>
                            <select id="tabFilter">
                                <option value="All">All</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Jobs Table Result Count -->
                    <div style="padding: 1rem 1rem 0.5rem; background: white; border-radius: 0.5rem 0.5rem 0 0; margin-bottom: -0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 0.875rem; color: var(--gray-700); font-weight: 600;">
                                <span id="jobsResultCount">0</span> <span style="color: var(--gray-500);">job(s) found</span>
                            </div>
                            <div style="font-size: 0.75rem; color: var(--gray-500);">
                                Total: <span id="jobsTotalCount">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="table-container" style="border-radius: 0 0 0.5rem 0.5rem;">
                        <div class="table-wrapper">
                            <table>
                                <thead>
                                    <tr>
                                        <th class="sortable" data-sort="name">Job Name</th>
                                        <th class="sortable" data-sort="time">Schedule Time</th>
                                        <th class="sortable" data-sort="frequency">Frequency / Day Info</th>
                                        <th class="sortable" data-sort="status">Status</th>
                                        <th class="sortable" data-sort="environment">Environment</th>
                                        <th>Command</th>
                                    </tr>
                                </thead>
                                <tbody id="jobsTableBody">
                                    <tr><td colspan="7" class="no-results">Loading...</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>
                
                <!-- Today's Report Section -->
                <section id="today-report-section" class="page-section active">
                    <div class="stats">
                        <div class="stat-card info clickable" id="todayCardTotal" onclick="filterTodayByCard('All')" title="Click to show all jobs">
                            <div class="stat-label">Total Jobs</div>
                            <div class="stat-value" id="todayTotal">0</div>
                            <div style="display: flex; gap: 0.75rem; margin-top: 0.5rem; font-size: 0.7rem;">
                                <div style="color: #92400e;">üü° <span id="todayTotalCanary">0</span></div>
                                <div style="color: #1e40af;">üîµ <span id="todayTotalNonCanary">0</span></div>
                            </div>
                        </div>
                        <div class="stat-card warning clickable" id="todayCardPending" onclick="filterTodayByCard('Pending')" title="Click to filter pending jobs">
                            <div class="stat-label">Pending Jobs</div>
                            <div class="stat-value" id="todayPending">0</div>
                            <div style="display: flex; gap: 0.75rem; margin-top: 0.5rem; font-size: 0.7rem;">
                                <div style="color: #92400e;">üü° <span id="todayPendingCanary">0</span></div>
                                <div style="color: #1e40af;">üîµ <span id="todayPendingNonCanary">0</span></div>
                            </div>
                        </div>
                        <div class="stat-card clickable" id="todayCardInProgress" onclick="filterTodayByCard('In Progress')" style="border-left-color: var(--info);" title="Click to filter in-progress jobs">
                            <div class="stat-label">In Progress Jobs</div>
                            <div class="stat-value" id="todayInProgress">0</div>
                            <div style="display: flex; gap: 0.75rem; margin-top: 0.5rem; font-size: 0.7rem;">
                                <div style="color: #92400e;">üü° <span id="todayInProgressCanary">0</span></div>
                                <div style="color: #1e40af;">üîµ <span id="todayInProgressNonCanary">0</span></div>
                            </div>
                        </div>
                        <div class="stat-card success clickable" id="todayCardSuccess" onclick="filterTodayByCard('Success')" title="Click to filter succeeded jobs">
                            <div class="stat-label">Succeeded Jobs</div>
                            <div class="stat-value" id="todaySucceeded">0</div>
                            <div style="display: flex; gap: 0.75rem; margin-top: 0.5rem; font-size: 0.7rem;">
                                <div style="color: #92400e;">üü° <span id="todaySucceededCanary">0</span></div>
                                <div style="color: #1e40af;">üîµ <span id="todaySucceededNonCanary">0</span></div>
                            </div>
                        </div>
                        <div class="stat-card danger clickable" id="todayCardFailed" onclick="filterTodayByCard('Failed')" title="Click to filter failed jobs">
                            <div class="stat-label">Failed Jobs</div>
                            <div class="stat-value" id="todayFailed">0</div>
                            <div style="display: flex; gap: 0.75rem; margin-top: 0.5rem; font-size: 0.7rem;">
                                <div style="color: #92400e;">üü° <span id="todayFailedCanary">0</span></div>
                                <div style="color: #1e40af;">üîµ <span id="todayFailedNonCanary">0</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Failed Schedulers Section -->
                    <div id="todayFailedSection" class="chart-container" style="display: none;">
                        <div class="chart-title" style="color: var(--danger);">‚ùå Failed Schedulers</div>
                        <div id="todayFailedList" style="display: grid; gap: 0.75rem; margin-top: 1rem;">
                            <!-- Failed jobs will be populated here -->
                        </div>
                    </div>
                    
                    <div class="table-container">
                        <div class="filters" style="padding: 1rem;">
                            <div class="filter-group">
                                <label>üîç Search</label>
                                <div class="search-wrapper">
                                    <input type="text" id="todaySearchInput" placeholder="Search analytic name...">
                                    <button class="search-clear-btn" onclick="clearTodaySearch()" title="Clear search">√ó</button>
                                </div>
                            </div>
                            <div class="filter-group">
                                <label>üìä Status</label>
                                <select id="todayStatusFilter">
                                    <option value="All">All</option>
                                    <option value="Pending">Pending</option>
                                    <option value="In Progress">In Progress</option>
                                    <option value="Success">Success</option>
                                    <option value="Failed">Failed</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label>üìÖ Frequency</label>
                                <select id="todayFrequencyFilter">
                                    <option value="All">All</option>
                                    <option value="Daily">Daily</option>
                                    <option value="Weekly">Weekly</option>
                                    <option value="Monthly">Monthly</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label>üåê Environment</label>
                                <select id="todayEnvironmentFilter">
                                    <option value="All">All</option>
                                    <option value="Canary">üü° Canary</option>
                                    <option value="Non-Canary">üîµ Non-Canary</option>
                                </select>
                            </div>
                            <div class="filter-group">
                                <label>üìÅ Tab</label>
                                <select id="todayTabFilter">
                                    <option value="All">All</option>
                                </select>
                            </div>
                        </div>
                        <div class="table-wrapper">
                            <table id="todaySchedulerTable">
                                <thead>
                                    <tr>
                                        <th class="sortable" data-key="analyticName">Analytic Name</th>
                                        <th class="sortable" data-key="executionSuccess">Status</th>
                                        <th>Time Slots</th>
                                        <th class="sortable" data-key="executionStartDate">Execution Time</th>
                                        <th class="sortable" data-key="duration">Duration</th>
                                        <th class="sortable" data-key="bqTotalData">BQ Data Fetch</th>
                                        <th class="sortable" data-key="analyticTotalData">Saved Data</th>
                                        <th>Env /<br>Frequency</th>
                                    </tr>
                                </thead>
                                <tbody id="todayTableBody">
                                    <tr><td colspan="8" class="no-results">Loading...</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>
                
                <!-- Reports Overview Section -->
                <section id="reports-overview-section" class="page-section">
                    <!-- Daily Breakdown Chart -->
                    <div class="chart-container" style="min-height: auto;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem;">
                            <div class="chart-title">üìä Daily Breakdown - Success vs Failed</div>
                            <div style="display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <div style="width: 14px; height: 14px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border-radius: 0.25rem; box-shadow: 0 1px 2px rgba(16, 185, 129, 0.3);"></div>
                                    <span style="font-weight: 500; font-size: 0.8125rem; color: var(--gray-700);">Success Schedulers</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <div style="width: 14px; height: 14px; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border-radius: 0.25rem; box-shadow: 0 1px 2px rgba(239, 68, 68, 0.3);"></div>
                                    <span style="font-weight: 500; font-size: 0.8125rem; color: var(--gray-700);">Failed Schedulers</span>
                                </div>
                            </div>
                        </div>
                        <div id="dailyBreakdownChart" style="width: 100%; overflow: hidden;"></div>
                    </div>
                    
                    <!-- Heatmap: Scheduler Activity by Hour -->
                    <div class="chart-container">
                        <div class="chart-title">üî• Scheduler Activity Heatmap (By Hour of Day)</div>
                        
                        <!-- Frequency Filter -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem;">
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="filter-btn active" id="heatmap-all" onclick="filterHeatmap('All')" 
                                        style="padding: 0.5rem 1rem; border: 1px solid var(--gray-300); border-radius: 0.375rem; 
                                        background: var(--primary); color: white; cursor: pointer; font-size: 0.875rem; font-weight: 500;">
                                    All
                                </button>
                                <button class="filter-btn" id="heatmap-daily" onclick="filterHeatmap('Daily')" 
                                        style="padding: 0.5rem 1rem; border: 1px solid var(--gray-300); border-radius: 0.375rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.875rem; font-weight: 500;">
                                    Daily
                                </button>
                                <button class="filter-btn" id="heatmap-weekly" onclick="filterHeatmap('Weekly')" 
                                        style="padding: 0.5rem 1rem; border: 1px solid var(--gray-300); border-radius: 0.375rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.875rem; font-weight: 500;">
                                    Weekly
                                </button>
                                <button class="filter-btn" id="heatmap-monthly" onclick="filterHeatmap('Monthly')" 
                                        style="padding: 0.5rem 1rem; border: 1px solid var(--gray-300); border-radius: 0.375rem; 
                                        background: white; color: var(--gray-700); cursor: pointer; font-size: 0.875rem; font-weight: 500;">
                                    Monthly
                                </button>
                            </div>
                            
                            <div style="display: flex; gap: 1rem; align-items: center; font-size: 0.875rem;">
                                <span style="color: var(--gray-600); font-weight: 500;">Legend:</span>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <div style="width: 20px; height: 20px; background: #10b981; border-radius: 0.25rem;"></div>
                                    <span>Success</span>
                                </div>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <div style="width: 20px; height: 20px; background: #f59e0b; border-radius: 0.25rem;"></div>
                                    <span>Retry</span>
                                </div>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <div style="width: 20px; height: 20px; background: #ef4444; border-radius: 0.25rem;"></div>
                                    <span>Failed</span>
                                </div>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <div style="width: 20px; height: 20px; background: #e5e7eb; border-radius: 0.25rem;"></div>
                                    <span>No Activity</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="heatmap-container" id="heatmapContainer">
                            <div class="no-results">Loading heatmap...</div>
                        </div>
                    </div>
                </section>
                
                <!-- Reports All Data Section -->
                <section id="reports-data-section" class="page-section">
                    <!-- Detailed Analysis Table -->
                    <div class="table-container">
                        <h3 style="padding: 1rem 1rem 0; font-size: 1.125rem; font-weight: 600;">üîç Detailed Execution Analysis</h3>
                        <div style="padding: 1rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                            <input type="search" id="patternSearchInput" placeholder="Search scheduler name..." 
                                   style="flex: 1; min-width: 250px; padding: 0.5rem 0.75rem; border: 1px solid var(--gray-300); 
                                   border-radius: 0.375rem; font-size: 0.875rem;">
                            <select id="patternDateFilter" onchange="filterPatternTable()" 
                                    style="padding: 0.5rem 0.75rem; border: 1px solid var(--gray-300); border-radius: 0.375rem; 
                                    font-size: 0.875rem; background: white; min-width: 150px;">
                                <option value="">All Dates</option>
                            </select>
                        </div>
                        <div class="table-wrapper">
                            <table>
                                <thead>
                                    <tr>
                                        <th class="sortable" onclick="sortPatternTable('analyticName')">Scheduler Name</th>
                                        <th class="sortable" onclick="sortPatternTable('date')">Date</th>
                                        <th class="sortable" onclick="sortPatternTable('timeSlot')">Time Slots</th>
                                        <th class="sortable" onclick="sortPatternTable('successSlot')">Success Time Slot</th>
                                        <th class="sortable" onclick="sortPatternTable('status')">Status</th>
                                        <th class="sortable" onclick="sortPatternTable('duration')">Duration</th>
                                        <th class="sortable" onclick="sortPatternTable('data')">Data Rows</th>
                                    </tr>
                                </thead>
                                <tbody id="patternMatchBody">
                                    <tr><td colspan="7" class="no-results">Loading...</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>
                
                <!-- Pattern Analysis Section -->
                <section id="reports-patterns-section" class="page-section">
                    <div class="stats">
                        <div class="stat-card info">
                            <div class="stat-label">Total Schedulers</div>
                            <div class="stat-value" id="patternTotalSchedulers">0</div>
                            <div class="stat-trend" id="patternSchedulersTrend"></div>
                        </div>
                        <div class="stat-card success">
                            <div class="stat-label">Success Rate</div>
                            <div class="stat-value" id="patternSuccessRate">0%</div>
                            <div class="stat-trend" id="patternSuccessTrend"></div>
                        </div>
                        <div class="stat-card primary">
                            <div class="stat-label">Peak Hour</div>
                            <div class="stat-value" id="patternPeakHour">--:--</div>
                            <div class="stat-trend" id="patternPeakTrend"></div>
                        </div>
                    </div>
                    
                    <!-- Duration Distribution Chart -->
                    <div class="chart-container" style="height: auto; min-height: 400px;">
                        <div class="chart-title">‚è±Ô∏è Duration Distribution (All Schedulers)</div>
                        <div id="durationChart"></div>
                    </div>
                </section>
            </div>
        </main>
    </div>
    
    <!-- Modal -->
    <div id="curlModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üìã Curl Command Details</h3>
                <button class="close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Job Details -->
                <div style="background: var(--gray-50); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; border-left: 3px solid var(--primary);">
                    <div style="margin-bottom: 0.75rem;">
                        <span style="font-size: 0.75rem; font-weight: 600; color: var(--gray-600); text-transform: uppercase; letter-spacing: 0.5px;">Job</span>
                        <div style="font-size: 1rem; font-weight: 600; color: var(--gray-900); margin-top: 0.25rem;" id="modalJobName"></div>
                    </div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 0.5rem 1rem; font-size: 0.875rem;">
                        <span style="font-weight: 600; color: var(--gray-600);">üåê Host:</span>
                        <span id="modalHost" style="color: var(--gray-900); font-family: monospace;"></span>
                        <span style="font-weight: 600; color: var(--gray-600);">üìÅ Path:</span>
                        <span id="modalPath" style="color: var(--gray-900); font-family: monospace; word-break: break-all;"></span>
                    </div>
                </div>
                
                <!-- Environment Toggle and Force Execute -->
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap;">
                    <div class="toggle-switch" style="margin-bottom: 0;">
                        <span class="toggle-label">Environment:</span>
                        <div class="toggle-buttons">
                            <button class="toggle-btn active" id="toggleNonCanary" onclick="toggleCanaryMode(false)">Non-Canary</button>
                            <button class="toggle-btn" id="toggleCanary" onclick="toggleCanaryMode(true)">Canary</button>
                        </div>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="checkbox" id="forceExecuteCheckbox" onchange="updateCurlCommand()" 
                               style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--primary);">
                        <label for="forceExecuteCheckbox" style="cursor: pointer; font-size: 0.875rem; font-weight: 600; color: var(--gray-700); user-select: none;">
                            ‚ö° Force Execute
                        </label>
                    </div>
                </div>
                
                <pre id="modalCurlCommand"></pre>
                <div style="display: flex; gap: 0.75rem; margin-bottom: 1rem;">
                    <button class="btn btn-success btn-sm" onclick="copyCurlCommand()">üìã Copy Command</button>
                    <button class="btn btn-primary btn-sm" id="executeCurlBtn" onclick="executeCurlCommand()" style="background: var(--primary); color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer; font-weight: 500;">
                        ‚ö° Execute
                    </button>
                </div>
                <div id="curlExecutionResults" style="display: none; margin-top: 1rem;">
                    <div style="background: var(--gray-50); padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--gray-200);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
                            <h4 style="margin: 0; font-size: 0.875rem; font-weight: 600; color: var(--gray-900);">Execution Results</h4>
                            <button onclick="document.getElementById('curlExecutionResults').style.display='none'" style="background: none; border: none; color: var(--gray-600); cursor: pointer; font-size: 1.25rem; padding: 0;">&times;</button>
                        </div>
                        <div id="curlExecutionOutput" style="background: white; padding: 0.75rem; border-radius: 0.375rem; border: 1px solid var(--gray-200); max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 0.8125rem; white-space: pre-wrap; word-wrap: break-word;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- BQ Details Modal -->
    <div id="bqDetailsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üìä BigQuery Details - <span id="bqModalJobNameHeader"></span></h3>
                <button class="close" onclick="closeBqDetailsModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 1rem;">
                <!-- BQ Projects Used -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; font-weight: 600; color: var(--gray-700); margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.375rem;">
                        <span>üè¢ BQ Projects Used:</span>
                        <span id="bqModalProjectCount" style="font-size: 0.6875rem; font-weight: 500; color: var(--gray-500);"></span>
                    </div>
                    <div id="bqModalProjects" style="background: var(--gray-50); padding: 0.75rem; border-radius: 0.375rem; border: 1px solid var(--gray-200);">
                        <!-- Projects will be populated here -->
                    </div>
                </div>
                
                <!-- Source (UDF/Datamarts) -->
                <div style="margin-bottom: 1rem;">
                    <div style="font-size: 0.75rem; font-weight: 600; color: var(--gray-700); margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.375rem;">
                        <span>üîó Source (UDF/Datamarts):</span>
                    </div>
                    <div style="background: var(--gray-50); padding: 0.625rem 0.75rem; border-radius: 0.375rem; border: 1px solid var(--gray-200);">
                        <code id="bqModalSource" style="font-size: 0.8125rem; color: var(--gray-900); font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; word-break: break-all;"></code>
                    </div>
                </div>
                
                <!-- Dependant Tables -->
                <div>
                    <div style="font-size: 0.75rem; font-weight: 600; color: var(--gray-700); margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.375rem;">
                        <span>üìã Dependant Tables:</span>
                        <span id="bqModalTableCount" style="font-size: 0.6875rem; font-weight: 500; color: var(--gray-500);"></span>
                    </div>
                    <div id="bqModalDependantTables" style="background: var(--gray-50); padding: 0.75rem; border-radius: 0.375rem; border: 1px solid var(--gray-200);">
                        <!-- Tables will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Scheduler Runs Modal -->
    <div id="schedulerRunsModal" class="modal">
        <div class="modal-content" style="max-width: 1200px;">
            <div class="modal-header">
                <h3 id="schedulerRunsModalTitle" style="font-size: 1.25rem;">üî• Scheduler Run Details</h3>
                <button class="close" onclick="closeSchedulerRunsModal()" style="font-size: 1.75rem;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 1.5rem;">
                <div id="schedulerRunsModalContent"></div>
            </div>
        </div>
    </div>
    
    <!-- Sales Funnel Validation Modal -->
    <div id="salesFunnelValidationModal" class="modal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header" style="flex-shrink: 0;">
                <h3 id="salesFunnelModalTitle">üîç Sales Funnel Validation</h3>
                <button class="close" onclick="closeSalesFunnelValidationModal()">&times;</button>
            </div>
            <div class="modal-body" style="flex: 1; overflow-y: auto; min-height: 0;">
                <div id="salesFunnelValidationContent">
                    <div style="padding: 1rem; background: var(--gray-50); border-radius: 0.5rem; color: var(--gray-600); margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Validating sales funnel reports...</div>
                        <div>This will check if the sum of Row Inserted from all pods matches the Saved Data in today's report.</div>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; background: var(--gray-50); border-radius: 0.5rem; margin-bottom: 1rem;">
                        <div style="font-size: 0.875rem; color: var(--gray-700);">
                            Checking if sum of rowsInserted matches SAVED DATA
                        </div>
                        <button id="validateSalesFunnelModalBtn" onclick="validateSalesFunnelFromModal()" 
                                style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500; font-size: 0.875rem;">
                            üîÑ Validate
                        </button>
                    </div>
                    <div id="salesFunnelValidationResults" style="margin-top: 1.5rem;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- SSO Token Modal -->
    <div id="ssoTokenModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3>üîë Update SSO Token</h3>
                <button class="close" onclick="closeSsoTokenModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 1rem; color: var(--gray-700);">
                    The current SSO token is invalid. Please enter a new token to continue.
                </p>
                <div style="margin-bottom: 1rem;">
                    <label for="ssoTokenInput" style="display: block; font-weight: 600; color: var(--gray-700); margin-bottom: 0.5rem;">
                        SSO Token:
                    </label>
                    <input 
                        type="text" 
                        id="ssoTokenInput" 
                        placeholder="Enter new SSO token"
                        style="width: 100%; padding: 0.75rem; border: 2px solid var(--gray-300); border-radius: 0.5rem; font-family: monospace; font-size: 0.875rem;"
                        onkeypress="if(event.key === 'Enter') updateSsoToken()"
                    />
                </div>
                <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
                    <button class="btn btn-secondary btn-sm" onclick="closeSsoTokenModal()">Cancel</button>
                    <button class="btn btn-primary btn-sm" onclick="updateSsoToken()">Update Token</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>
    
    <script>
        // Canary Cookie Value
        const CANARY_COOKIE = '__bwa_user_id=657116261.U.3972438181951890.1660647073; _vwo_uuid_v2=DFBEE5736AFAB4C1BEDEB33E3710EC953|c38d9dc86f328ff3a67df0f80cd24218; _fbp=fb.1.1687412890719.927626789; afUserId=5c97cc6f-85ff-4f76-95b6-4bcd119e31ab-p; Static-Base-Url="https://www.static-src.com"; Has-Login-History=true; _ga_71BLJD18MP=deleted; _ga_71BLJD18MP=deleted; _gcl_au=1.1.1734537722.1742533786; IR_gbd=blibli.com; cebs=1; _vwo_uuid=D9325CACBD354ADF462D059C17D37F5FB; _vis_opt_s=1%7C; _vis_opt_test_cookie=1; _vwo_ssm=1; _vwo_ds=3%3At_0%2Ca_0%3A0%241742533786%3A36.37716957%3A%3A%3A%3A0; Blibli-Device-Id=U.1c5c9c80-20e8-4024-9893-70c46223a23f; Blibli-Device-Id-Signature=4427c723a38072a10880b842dae7abb0247cdcc3; QrCodeGenerationTutuorial=["cc824edd-05b4-479a-a2d5-48afdb43d34e"]; creationTutorialVisitedUser=["cc824edd-05b4-479a-a2d5-48afdb43d34e"]; userPicTickerVisitedUserPdp=["cc824edd-05b4-479a-a2d5-48afdb43d34e"]; multipPpTutorialVisitedUser=["cc824edd-05b4-479a-a2d5-48afdb43d34e"]; __gtm_cam=; __gtm_src=affiliates; _vis_opt_exp_516_exclude=1; productOptimisationBanner=["cc824edd-05b4-479a-a2d5-48afdb43d34e"]; _vis_opt_exp_497_exclude=1; __gtm_med=1299619_Love Savings Group; AF_SYNC=1747919929657; Announcement-Has-Been-Read=true; IR_PI=5ed22751-10c0-11ee-baa1-810287776b27%7C1747941199745; _gid=GA1.2.2082243399.1748235048; _ce.clock_data=-105%2C49.206.115.41%2C1%2C8b2bf32448aaaa1415d4b0b61938828d%2CEdge%2CIN; IR_19024=1748235052297%7C4120732%7C1748235052297%7C17m2Fhxz0xyPTOpUw2UFa3IqUksWXP2gZSo8yE0%7C; forterToken=5bc29b922ef74b7cb68e9d45f2c79313_1748235054462__UDF43-m4_25ck_; Partners-Device-Id=d9c56577-9703-4db7-8373-b2f0203366f4; Partners-Sso-Type=OpenID; Partners-Username=sachin.ravanth@gdn-commerce.com; Partners-User-Id=cc824edd-05b4-479a-a2d5-48afdb43d34e; Partners-Signature=A300E614886D5198D5C8E579274121DABD8A7CCE19EDE66F81E85F78D9155E6B; Blibli-Extras-MerchantId=RAM-70107; _ga_G3ZP2F3MW9=GS2.1.s1748235053$o159$g0$t1748235757$j60$l0$h924341940$dkwfhkqXNc8Ls5n4IGULYI8iU_Nxw77ybng; __cf_bm=8jlubjmONqecTPnNx.JxbkwSCptNZQQKrS1t241LJ4o-1748237701-1.0.1.1-Y.DHWcgR6jGeNTmR9GoiEJSevQ0E6gPW1UbwQRVXdE_yAkBoutbbIoQYBy7.JIbAkbpSMF6UWo5Zlw7gvw55TEkCfanHUS5qLrN9VH9X28w; _vwo_sn=5410220%3A%3A%3A%3A1; _gat_UA-21718848-28=1; cf_clearance=CutPv.gIAHYIhFLaNpjFhXQoWFVBoBhk_rzJbG1uPFs-1748238168-1.2.1.1-Klf9lIxSdlSnlmeQq06dC6PjMa0igG3Ma0Vpoa2HhRlK1T.yps312XQCrgycPKxWWlGAbP3z4ooEi9T51BvX5089109SLEmc9n8l3qWsFeYiJ2PrDwZVhl9nftfyzU4jOd9gBUOpciNwnNYUW6A07WsdYSrvwNvEF1JicB4kBqWnDPbwL1xlqe8idP0XQfaWAZlm6jFzt7l5I3SeqeG10Nl.Krn3Zsor.AqmVmNXNzHmN1Cr8uiIvs.ww_wsxRHoa0_rkf8ufRgjQfu6UqA2gvO6oR_f8pGDM55uC6E41KW9LtA5AbnL_4RBxn8a1qzNmO1Kn2sjRrRMM6zdqTy1w624qBdNYrA7T2EIOw.qp8s; __bwa_session_id=1432166451.S.4429960498796943.1748238169; __bwa_user_session_sequence=295; _ce.s=v~70f9e88dc7ec439badd9661a8335477de7f61609~vpv~18~v11.rlc~1693457238074~lcw~1748235428984~ir~1~v11.fhb~1747287849213~v11.lhb~1747316495275~lva~1748235048600~vir~returning~v11ls~fe3f1ee0-39ec-11f0-b758-677d31b88d50~gtrk.la~mazrls36~v11.cs~295312~v11.s~fe3f1ee0-39ec-11f0-b758-677d31b88d50~v11.vs~70f9e88dc7ec439badd9661a8335477de7f61609~v11.ss~1748235048913~lcw~1748238169635; moe_uuid=3a165403-455f-4aaa-b7e5-16fd60df6d64; Partners-Canary-Flag=true; SESSION=58d4a391-f2e2-4478-b792-85af446f245c; _ga_71BLJD18MP=GS2.1.s1748237853$o239$g1$t1748238220$j0$l0$h0; _ga=GA1.2.1253831296.1660647073; __bwa_session_action_sequence=3; cebsp_=650; JSESSIONID=55F36300E695CD5BF01F19EB8350B244; __cf_bm=BDQF7VJx25tLFqe8jSIzz36jX5fWEQxMqi9rdk.SJw4-1748238220-1.0.1.1-QMVunfVeCd4GAE06PE4aNQM.hFGEpYjp00TPFNsNGbN8xuzK3ggFLZosCpqwTMOMdk5U2G848NFkk3x2pOyw_m8mEk3mWNlbgrKITO6OV0Q';
        
        // Data Arrays - Will be loaded from external JSON files
        let JOBS_DATA = [];
        let TODAY_DATA = [];
        let REPORTS_DATA = [];
        let FILTERED_REPORTS_DATA = []; // Filtered version of REPORTS_DATA based on selected filter
        
        // Function to check if cache is valid (TTL: 1 day)
        async function isCacheValid(cacheType) {
            try {
                const response = await fetch(`/api/get-last-updated?type=${cacheType}`);
                const result = await response.json();
                return result.success && result.timestamp;
            } catch (error) {
                console.error(`Failed to check cache validity for ${cacheType}:`, error);
                return false;
            }
        }
        
        // Function to load data from JSON files
        async function loadData() {
            try {
                // Check cache validity before loading
                const todayCacheValid = await isCacheValid('todayData');
                const pastCacheValid = await isCacheValid('pastData');
                
                if (!todayCacheValid) {
                    console.warn('today-data.json cache is expired or missing. Consider refreshing.');
                }
                if (!pastCacheValid) {
                    console.warn('past-data.json cache is expired or missing. Consider refreshing.');
                }
                
                const [jobsResponse, todayResponse, reportsResponse] = await Promise.all([
                    fetch('jobs-data.json'),
                    fetch('.validation_cache/today-data.json'),
                    fetch('.validation_cache/past-data.json')
                ]);
                
                JOBS_DATA = await jobsResponse.json();
                TODAY_DATA = await todayResponse.json();
                REPORTS_DATA = await reportsResponse.json();
                
                // Initialize filtered data based on current filter selection
                FILTERED_REPORTS_DATA = getFilteredReportsData();
                
                return true;
            } catch (error) {
                console.error('Error loading data:', error);
                
                // Provide helpful error message
                const errorMsg = `Failed to load data files.

CORS Error Detected: Browsers block loading local files via fetch() for security reasons.

To fix this, run a local web server:

Option 1 - Python (if installed):
  ‚Ä¢ Open Terminal in this folder
  ‚Ä¢ Run: python3 -m http.server 8000
  ‚Ä¢ Open: http://localhost:8000/scheduler-dashboard.html

Option 2 - Python 2:
  ‚Ä¢ Run: python -m SimpleHTTPServer 8000
  ‚Ä¢ Open: http://localhost:8000/scheduler-dashboard.html

Option 3 - PHP (if installed):
  ‚Ä¢ Run: php -S localhost:8000
  ‚Ä¢ Open: http://localhost:8000/scheduler-dashboard.html

Option 4 - Node.js (if installed):
  ‚Ä¢ Run: npx http-server -p 8000
  ‚Ä¢ Open: http://localhost:8000/scheduler-dashboard.html`;
                
                alert(errorMsg);
                return false;
            }
        }
        
        // Function to refresh past data - fetches last 14 days and stores in past-data.json
        async function refreshPastData() {
            const refreshBtn = document.getElementById('refreshPastDataBtn');
            const refreshIcon = document.getElementById('refreshPastDataIcon');
            const refreshText = document.getElementById('refreshPastDataText');
            const statusSpan = document.getElementById('pastDataStatus');
            
            if (!refreshBtn) return;
            
            // Disable button and show loading state
            refreshBtn.disabled = true;
            refreshIcon.textContent = '‚è≥';
            refreshText.textContent = 'Refreshing...';
            
            // Update status
            if (statusSpan) {
                statusSpan.textContent = 'Fetching last 14 days of data (excluding today)...';
                statusSpan.style.color = 'var(--primary)';
            }
            
            try {
                const response = await fetch('/api/fetch-past-data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        date_range: 'LAST_14_DAYS_EXCLUDING_TODAY',
                        sso_token: getSsoToken()
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update last fetched time
                    updatePastDataLastUpdatedTime();
                    
                    // Update status
                    if (statusSpan) {
                        statusSpan.textContent = `‚úì ${result.message}`;
                        statusSpan.style.color = '#10b981';
                        // Clear status after 3 seconds, then reload last updated time to check if it's from today
                        setTimeout(() => {
                            if (statusSpan) {
                                statusSpan.textContent = '';
                            }
                            // Reload last updated time to check if it's from today and show warning if needed
                            loadPastDataLastUpdatedTime();
                        }, 3000);
                    } else {
                        // If no statusSpan, just reload last updated time
                        loadPastDataLastUpdatedTime();
                    }
                    
                    // Reload past data
                    await loadData();
                    
                    // Update filtered data based on current filter selection
                    FILTERED_REPORTS_DATA = getFilteredReportsData();
                    
                    // Preserve current heatmap frequency filter
                    const heatmapFrequency = document.querySelector('.filter-btn.active[id^="heatmap-"]');
                    const currentFrequency = heatmapFrequency ? heatmapFrequency.textContent.trim() : 'All';
                    
                    // Refresh Reports Overview page (reports-overview-section)
                    displayReportsDateRange();
                    updateInsights();
                    updatePerformance();
                    renderDailyBreakdownChart();
                    
                    // Refresh Pattern Analysis page (reports-patterns-section)
                    // This updates stats, duration chart, attempt chart, and heatmap
                    // Note: initPatternAnalysis() calls renderHeatmap('All'), so we'll restore the filter after
                    initPatternAnalysis();
                    
                    // Restore heatmap filter for Reports Overview (if it was different from 'All')
                    if (currentFrequency !== 'All') {
                        renderHeatmap(currentFrequency);
                    }
                    
                    // Refresh All Scheduler Data page (reports-data-section)
                    // This updates the pattern match table
                    populatePatternDateFilter();
                    filterPatternTable();
                    
                    // Also refresh reports table if it exists (for any other reports views)
                    if (typeof renderReportsTable === 'function') {
                        renderReportsTable();
                    }
                } else {
                    // Show error
                    if (statusSpan) {
                        statusSpan.textContent = `‚úó Error: ${result.error || 'Failed to fetch data'}`;
                        statusSpan.style.color = '#ef4444';
                    }
                    console.error('Error refreshing past data:', result);
                }
            } catch (error) {
                // Show error
                if (statusSpan) {
                    statusSpan.textContent = `‚úó Error: ${error.message}`;
                    statusSpan.style.color = '#ef4444';
                }
                console.error('Error refreshing past data:', error);
            } finally {
                // Re-enable button and restore state
                refreshBtn.disabled = false;
                refreshIcon.textContent = 'üîÑ';
                refreshText.textContent = 'Refresh';
            }
        }
        
        // Function to get filtered reports data based on selected date range filter
        function getFilteredReportsData() {
            const filterSelect = document.getElementById('pastDataFilter');
            if (!filterSelect || REPORTS_DATA.length === 0) {
                return REPORTS_DATA;
            }
            
            const dateRange = filterSelect.value;
            
            // Get current time and calculate WIB timezone offset (UTC+7)
            const wibOffset = 7 * 60 * 60 * 1000; // UTC+7 in milliseconds
            const now = Date.now();
            const nowWIB = new Date(now + wibOffset);
            
            // Get start of today in WIB
            const todayStartWIB = new Date(nowWIB);
            todayStartWIB.setUTCHours(0, 0, 0, 0);
            const todayStartMs = todayStartWIB.getTime() - wibOffset;
            
            let startMs, endMs;
            
            if (dateRange === 'YESTERDAY') {
                // Yesterday: start of yesterday 00:00:00 to end of yesterday 23:59:59 (WIB timezone)
                const yesterdayStartWIB = new Date(todayStartWIB);
                yesterdayStartWIB.setUTCDate(yesterdayStartWIB.getUTCDate() - 1);
                const yesterdayEndWIB = new Date(yesterdayStartWIB);
                yesterdayEndWIB.setUTCHours(23, 59, 59, 999);
                
                startMs = yesterdayStartWIB.getTime() - wibOffset;
                endMs = yesterdayEndWIB.getTime() - wibOffset;
            } else if (dateRange === 'LAST_7_DAYS') {
                // Last 7 days: from 7 days ago start of day to today end of day
                const sevenDaysAgoStartWIB = new Date(todayStartWIB);
                sevenDaysAgoStartWIB.setUTCDate(sevenDaysAgoStartWIB.getUTCDate() - 7);
                const todayEndWIB = new Date(todayStartWIB);
                todayEndWIB.setUTCHours(23, 59, 59, 999);
                
                startMs = sevenDaysAgoStartWIB.getTime() - wibOffset;
                endMs = todayEndWIB.getTime() - wibOffset;
            } else if (dateRange === 'LAST_14_DAYS') {
                // Last 14 days: from 14 days ago start of day to today end of day
                const fourteenDaysAgoStartWIB = new Date(todayStartWIB);
                fourteenDaysAgoStartWIB.setUTCDate(fourteenDaysAgoStartWIB.getUTCDate() - 14);
                const todayEndWIB = new Date(todayStartWIB);
                todayEndWIB.setUTCHours(23, 59, 59, 999);
                
                startMs = fourteenDaysAgoStartWIB.getTime() - wibOffset;
                endMs = todayEndWIB.getTime() - wibOffset;
            } else {
                // Default: return all data
                return REPORTS_DATA;
            }
            
            // Filter REPORTS_DATA based on analyticDate
            // analyticDate represents start of day in WIB, so we check if it falls within the range
            return REPORTS_DATA.filter(item => {
                const analyticDate = parseInt(item.analyticDate);
                if (isNaN(analyticDate)) return false;
                
                // For YESTERDAY, we want records where analyticDate equals yesterday's start
                // For date ranges, we want records where analyticDate is within the range
                if (dateRange === 'YESTERDAY') {
                    // Check if analyticDate is yesterday's start of day
                    const yesterdayStartWIB = new Date(todayStartWIB);
                    yesterdayStartWIB.setUTCDate(yesterdayStartWIB.getUTCDate() - 1);
                    const yesterdayStartMs = yesterdayStartWIB.getTime() - wibOffset;
                    return analyticDate === yesterdayStartMs;
                } else {
                    // For ranges, check if analyticDate is within the range
                    return analyticDate >= startMs && analyticDate <= endMs;
                }
            });
        }
        
        // Function to filter past data based on dropdown selection (client-side filtering only, no API calls)
        function filterPastData() {
            // Update filtered data based on current filter selection
            FILTERED_REPORTS_DATA = getFilteredReportsData();
            
            // Preserve current heatmap frequency filter
            const heatmapFrequency = document.querySelector('.filter-btn.active[id^="heatmap-"]');
            const currentFrequency = heatmapFrequency ? heatmapFrequency.textContent.trim() : 'All';
            
            // Refresh Reports Overview page (reports-overview-section)
            displayReportsDateRange();
            updateInsights();
            updatePerformance();
            renderDailyBreakdownChart();
            
            // Refresh Pattern Analysis page (reports-patterns-section)
            // This updates stats, duration chart, attempt chart, and heatmap
            // Note: initPatternAnalysis() calls renderHeatmap('All'), so we'll restore the filter after
            initPatternAnalysis();
            
            // Restore heatmap filter for Reports Overview (if it was different from 'All')
            if (currentFrequency !== 'All') {
                renderHeatmap(currentFrequency);
            }
            
            // Refresh All Scheduler Data page (reports-data-section)
            // This updates the pattern match table
            populatePatternDateFilter();
            filterPatternTable();
            
            // Also refresh reports table if it exists (for any other reports views)
            if (typeof renderReportsTable === 'function') {
                renderReportsTable();
            }
        }
        
        // Function to update last updated time for past data
        async function updatePastDataLastUpdatedTime() {
            const lastUpdatedEl = document.getElementById('pastDataLastUpdatedTime');
            if (!lastUpdatedEl) return;
            
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const dateStr = now.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
            
            lastUpdatedEl.textContent = `Last updated: ${dateStr} ${timeStr}`;
            lastUpdatedEl.style.display = 'inline';
            
            // Store in validation cache (server-side) with 1-day expiry
            try {
                await fetch('/api/set-last-updated', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        type: 'pastData',
                        timestamp: now.toISOString()
                    })
                });
            } catch (error) {
                console.error('Failed to save past data last updated time:', error);
            }
        }
        
        // Function to load and display last updated time for past data
        async function loadPastDataLastUpdatedTime() {
            const lastUpdatedEl = document.getElementById('pastDataLastUpdatedTime');
            const statusEl = document.getElementById('pastDataStatus');
            if (!lastUpdatedEl) return;
            
            try {
                const response = await fetch('/api/get-last-updated?type=pastData');
                const result = await response.json();
                
                if (result.success && result.timestamp) {
                    const lastUpdated = new Date(result.timestamp);
                    const now = new Date();
                    
                    // Check if the timestamp is from today
                    const isFromToday = lastUpdated.getFullYear() === now.getFullYear() &&
                                      lastUpdated.getMonth() === now.getMonth() &&
                                      lastUpdated.getDate() === now.getDate();
                    
                    const timeStr = lastUpdated.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    const dateStr = lastUpdated.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric'
                    });
                    
                    lastUpdatedEl.textContent = `Last updated: ${dateStr} ${timeStr}`;
                    lastUpdatedEl.style.display = 'inline';
                    
                    // Show warning if data was not refreshed today
                    if (!isFromToday && statusEl) {
                        statusEl.innerHTML = `<span style="color: #dc2626; font-weight: 600; padding: 0.25rem 0.5rem; background: #fee2e2; border-radius: 0.25rem; display: inline-flex; align-items: center; gap: 0.25rem;">
                            ‚ö†Ô∏è Data not refreshed today. Please click Refresh to update.
                        </span>`;
                        statusEl.style.display = 'inline';
                    } else if (statusEl) {
                        // Clear status if data is fresh
                        statusEl.textContent = '';
                        statusEl.style.display = 'none';
                    }
                } else {
                    // Show "-" when no last updated time exists or cache expired
                    lastUpdatedEl.textContent = 'Last updated: -';
                    lastUpdatedEl.style.display = 'inline';
                    
                    // Show warning to refresh
                    if (statusEl) {
                        statusEl.innerHTML = `<span style="color: #dc2626; font-weight: 600; padding: 0.25rem 0.5rem; background: #fee2e2; border-radius: 0.25rem; display: inline-flex; align-items: center; gap: 0.25rem;">
                            ‚ö†Ô∏è Data not available. Please click Refresh to fetch data.
                        </span>`;
                        statusEl.style.display = 'inline';
                    }
                }
            } catch (error) {
                console.error('Failed to load past data last updated time:', error);
                lastUpdatedEl.textContent = 'Last updated: -';
                lastUpdatedEl.style.display = 'inline';
                
                // Show warning on error
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color: #dc2626; font-weight: 600; padding: 0.25rem 0.5rem; background: #fee2e2; border-radius: 0.25rem; display: inline-flex; align-items: center; gap: 0.25rem;">
                        ‚ö†Ô∏è Unable to check data status. Please click Refresh to ensure data is up to date.
                    </span>`;
                    statusEl.style.display = 'inline';
                }
            }
        }
        
        // Function to update last updated time display
        async function updateLastUpdatedTime(isTodayReport = false) {
            const lastUpdatedEl = document.getElementById('lastUpdatedTime');
            if (!lastUpdatedEl) return;
            
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            const dateStr = now.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
            
            lastUpdatedEl.textContent = `Last updated: ${dateStr} ${timeStr}`;
            
            // Show the element if on Today's Report page
            if (isTodayReport) {
                lastUpdatedEl.style.display = 'inline';
                
                // Store in validation cache (server-side) with 1-day expiry
                try {
                    await fetch('/api/set-last-updated', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            type: 'todayData',
                            timestamp: now.toISOString()
                        })
                    });
                } catch (error) {
                    console.error('Failed to save today data last updated time:', error);
                }
            }
        }
        
        // Function to load and display last updated time
        async function loadLastUpdatedTime(isTodayReport = false) {
            const lastUpdatedEl = document.getElementById('lastUpdatedTime');
            if (!lastUpdatedEl || !isTodayReport) {
                if (lastUpdatedEl) {
                    lastUpdatedEl.style.display = 'none';
                }
                return;
            }
            
            try {
                const response = await fetch('/api/get-last-updated?type=todayData');
                const result = await response.json();
                
                if (result.success && result.timestamp) {
                    const lastUpdated = new Date(result.timestamp);
                    const now = new Date();
                    
                    // Check if the timestamp is from today
                    const isFromToday = lastUpdated.getFullYear() === now.getFullYear() &&
                                      lastUpdated.getMonth() === now.getMonth() &&
                                      lastUpdated.getDate() === now.getDate();
                    
                    const timeStr = lastUpdated.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    const dateStr = lastUpdated.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric'
                    });
                    
                    lastUpdatedEl.textContent = `Last updated: ${dateStr} ${timeStr}`;
                    lastUpdatedEl.style.display = 'inline';
                    
                    // If timestamp is not from today, prompt user to refresh
                    if (!isFromToday) {
                        setTimeout(() => {
                            const shouldRefresh = confirm('Today\'s data has not been refreshed yet. Would you like to refresh it now?');
                            if (shouldRefresh) {
                                refreshData();
                            }
                        }, 500); // Small delay to let the page finish loading
                    }
                } else {
                    // Show "-" when no last updated time exists or cache expired
                    lastUpdatedEl.textContent = 'Last updated: -';
                    lastUpdatedEl.style.display = 'inline';
                    
                    // Prompt user to refresh data
                    setTimeout(() => {
                        const shouldRefresh = confirm('Today\'s data has not been refreshed yet. Would you like to refresh it now?');
                        if (shouldRefresh) {
                            refreshData();
                        }
                    }, 500); // Small delay to let the page finish loading
                }
            } catch (error) {
                console.error('Failed to load today data last updated time:', error);
                lastUpdatedEl.textContent = 'Last updated: -';
                lastUpdatedEl.style.display = 'inline';
                
                // Prompt user to refresh data
                setTimeout(() => {
                    const shouldRefresh = confirm('Today\'s data has not been refreshed yet. Would you like to refresh it now?');
                    if (shouldRefresh) {
                        refreshData();
                    }
                }, 500);
            }
        }
        
        // Toast notification function
        function showToast(title, message, type = 'success', duration = 4000) {
            const container = document.getElementById('toastContainer');
            if (!container) return;
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };
            
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.success}</span>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.closest('.toast').remove()">√ó</button>
            `;
            
            container.appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.classList.add('hiding');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 300);
            }, duration);
        }
        
        // Store current scheduler name and record for validation
        let currentSchedulerName = null;
        let currentSchedulerRecord = null;
        
        // Function to show sales funnel validation modal
        function showSalesFunnelValidationModal(schedulerName) {
            currentSchedulerName = schedulerName;
            
            // Try to find the scheduler record from current page data
            currentSchedulerRecord = null;
            if (window.todayScheduledData && Array.isArray(window.todayScheduledData)) {
                currentSchedulerRecord = window.todayScheduledData.find(job => job.analyticName === schedulerName);
            }
            
            const modal = document.getElementById('salesFunnelValidationModal');
            if (modal) {
                modal.style.display = 'block';
                
                // Build scheduler details section if record is available
                let schedulerDetailsHtml = '';
                if (currentSchedulerRecord) {
                    const isPending = !currentSchedulerRecord.executionStartDate && currentSchedulerRecord.executionSuccess === undefined;
                    const isInProgress = currentSchedulerRecord.executionStartDate && !currentSchedulerRecord.executionFinishDate;
                    const isSuccess = currentSchedulerRecord.executionSuccess === true;
                    const isFailed = currentSchedulerRecord.executionSuccess === false;
                    
                    let statusText, statusClass;
                    if (isPending) {
                        statusText = 'Pending';
                        statusClass = 'status-pending';
                    } else if (isInProgress) {
                        statusText = 'In Progress';
                        statusClass = 'status-in-progress';
                    } else if (isSuccess) {
                        statusText = 'Success';
                        statusClass = 'status-success';
                    } else {
                        statusText = 'Fail';
                        statusClass = 'status-fail';
                    }
                    
                    const statusBgColor = statusClass === 'status-success' ? '#d1fae5' : 
                                         statusClass === 'status-fail' ? '#fee2e2' :
                                         statusClass === 'status-in-progress' ? '#dbeafe' : '#fef3c7';
                    const statusFgColor = statusClass === 'status-success' ? '#065f46' : 
                                         statusClass === 'status-fail' ? '#991b1b' :
                                         statusClass === 'status-in-progress' ? '#1e40af' : '#92400e';
                    
                    // Calculate duration
                    let duration = '-';
                    if (currentSchedulerRecord.executionStartDate && currentSchedulerRecord.executionFinishDate) {
                        const start = parseInt(currentSchedulerRecord.executionStartDate);
                        const end = parseInt(currentSchedulerRecord.executionFinishDate);
                        const diffMs = end - start;
                        const hours = Math.floor(diffMs / (1000 * 60 * 60));
                        const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
                        duration = `${hours}h ${minutes}m ${seconds}s`;
                    }
                    
                    schedulerDetailsHtml = `
                        <div style="padding: 0.75rem; background: white; border: 1px solid var(--gray-200); border-radius: 0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 1rem;">
                            <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.75rem; align-items: center;">
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Status</div>
                                    <div style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; display: inline-block; font-size: 0.75rem; font-weight: 600; background: ${statusBgColor}; color: ${statusFgColor};">
                                        ${statusText}
                                    </div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Start Time</div>
                                    <div style="font-size: 0.875rem; font-weight: 600; color: var(--gray-900); font-family: monospace;">${currentSchedulerRecord.executionStartDate ? formatTimeOnly(currentSchedulerRecord.executionStartDate) : '-'}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">End Time</div>
                                    <div style="font-size: 0.875rem; font-weight: 600; color: var(--gray-900); font-family: monospace;">${currentSchedulerRecord.executionFinishDate ? formatTimeOnly(currentSchedulerRecord.executionFinishDate) : '-'}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Duration</div>
                                    <div style="font-size: 0.875rem; font-weight: 600; color: var(--gray-900);">${duration}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">BQ Data Fetch</div>
                                    <div style="font-size: 0.875rem; font-weight: 600; color: var(--gray-900);">${currentSchedulerRecord.bqTotalData !== undefined ? (typeof currentSchedulerRecord.bqTotalData === 'number' ? currentSchedulerRecord.bqTotalData.toLocaleString() : currentSchedulerRecord.bqTotalData) : '-'}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Saved Data</div>
                                    <div style="font-size: 0.875rem; font-weight: 600; color: var(--gray-900);">${currentSchedulerRecord.analyticTotalData !== undefined ? (typeof currentSchedulerRecord.analyticTotalData === 'number' ? currentSchedulerRecord.analyticTotalData.toLocaleString() : currentSchedulerRecord.analyticTotalData) : '-'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                // Update modal title with analytic name and date
                const modalTitleEl = document.getElementById('salesFunnelModalTitle');
                if (modalTitleEl) {
                    let titleText = `üîç Validate: ${schedulerName}`;
                    if (currentSchedulerRecord && currentSchedulerRecord.analyticDate) {
                        const analyticDate = new Date(parseInt(currentSchedulerRecord.analyticDate));
                        const dateStr = analyticDate.toLocaleDateString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric'
                        });
                        titleText += ` - ${dateStr}`;
                    }
                    modalTitleEl.textContent = titleText;
                }
                
                // Reset content with scheduler details at top
                document.getElementById('salesFunnelValidationContent').innerHTML = `
                    ${schedulerDetailsHtml}
                    <div id="salesFunnelActionSection" style="padding: 0.75rem; background: var(--gray-50); border-radius: 0.5rem; margin-bottom: 1rem;">
                        <div style="display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; flex-wrap: wrap;">
                            <p style="margin: 0; font-size: 0.85rem; color: var(--gray-700); line-height: 1.5; flex: 1; min-width: 200px;">
                                Verify that the sum of <strong>Row Inserted</strong> from all pods matches the <strong>Saved Data</strong> value
                            </p>
                            <div style="display: flex; align-items: center; gap: 0.75rem; flex-shrink: 0;">
                                <div id="clearCacheInlineSection" style="display: none;"></div>
                                <button id="validateSalesFunnelModalBtn" onclick="validateSalesFunnelFromModal()" 
                                        style="padding: 0.6rem 1.5rem; background: var(--primary); color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 600; font-size: 0.9rem; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.2s;">
                                    üîÑ Run Validation
                                </button>
                            </div>
                        </div>
                    </div>
                    <div id="salesFunnelValidationResults" style="margin-top: 1rem;"></div>
                `;
            }
        }
        
        function closeSalesFunnelValidationModal() {
            const modal = document.getElementById('salesFunnelValidationModal');
            if (modal) {
                modal.style.display = 'none';
                // Reset modal title
                const modalTitleEl = document.getElementById('salesFunnelModalTitle');
                if (modalTitleEl) {
                    modalTitleEl.textContent = 'üîç Validate: Sales Funnel';
                }
                // Hide clear cache section
                const clearCacheInlineSection = document.getElementById('clearCacheInlineSection');
                if (clearCacheInlineSection) {
                    clearCacheInlineSection.style.display = 'none';
                    clearCacheInlineSection.innerHTML = '';
                }
            }
        }
        
        // Function to clear sales funnel cache for a specific scheduler
        async function clearSalesFunnelCache(schedulerName) {
            if (!schedulerName) {
                showToast('Error', 'No scheduler specified', 'error', 3000);
                return;
            }
            
            const btn = document.getElementById('clearCacheBtn');
            
            // Disable button and show loading state
            if (btn) {
                btn.disabled = true;
                btn.style.opacity = '0.7';
                btn.style.cursor = 'not-allowed';
                btn.innerHTML = '<span>‚è≥</span><span>Clearing...</span>';
                btn.style.transform = 'none';
                btn.onmouseover = null;
                btn.onmouseout = null;
            }
            
            try {
                const response = await fetch('/api/clear-sales-funnel-cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        scheduler_name: schedulerName
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    showToast('Cache Cleared', `Cache cleared for ${schedulerName}`, 'success', 3000);
                    
                    // Clear the validation results display
                    const resultsDiv = document.getElementById('salesFunnelValidationResults');
                    if (resultsDiv) {
                        resultsDiv.innerHTML = '';
                    }
                    
                    // Hide the clear cache button since cache is now cleared
                    const clearCacheInlineSection = document.getElementById('clearCacheInlineSection');
                    if (clearCacheInlineSection) {
                        clearCacheInlineSection.style.display = 'none';
                        clearCacheInlineSection.innerHTML = '';
                    }
                    
                    // Restore button state
                    if (btn) {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                        btn.innerHTML = '<span>üóëÔ∏è</span><span>Clear Cache</span>';
                        // Restore hover effects - determine colors from badge in parent container
                        const parentDiv = btn.closest('div');
                        const badge = parentDiv?.querySelector('span[style*="background"]');
                        const isFromCache = badge && badge.style.background.includes('fef3c7');
                        const buttonBg = isFromCache ? '#f59e0b' : '#059669';
                        const buttonHoverBg = isFromCache ? '#d97706' : '#047857';
                        btn.style.background = buttonBg;
                        btn.onmouseover = function() {
                            if (!this.disabled) {
                                this.style.background = buttonHoverBg;
                                this.style.transform = 'translateY(-1px)';
                            }
                        };
                        btn.onmouseout = function() {
                            if (!this.disabled) {
                                this.style.background = buttonBg;
                                this.style.transform = 'translateY(0)';
                            }
                        };
                    }
                } else {
                    throw new Error(result.error || 'Failed to clear cache');
                }
            } catch (error) {
                console.error('Error clearing cache:', error);
                showToast('Error', `Failed to clear cache: ${error.message}`, 'error', 4000);
                if (btn) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                    btn.innerHTML = '<span>üóëÔ∏è</span><span>Clear Cache</span>';
                    // Restore hover effects - determine colors from badge in parent container
                    const parentDiv = btn.closest('div');
                    const badge = parentDiv?.querySelector('span[style*="background"]');
                    const isFromCache = badge && badge.style.background.includes('fef3c7');
                    const buttonBg = isFromCache ? '#f59e0b' : '#059669';
                    const buttonHoverBg = isFromCache ? '#d97706' : '#047857';
                    btn.style.background = buttonBg;
                    btn.onmouseover = function() {
                        if (!this.disabled) {
                            this.style.background = buttonHoverBg;
                            this.style.transform = 'translateY(-1px)';
                        }
                    };
                    btn.onmouseout = function() {
                        if (!this.disabled) {
                            this.style.background = buttonBg;
                            this.style.transform = 'translateY(0)';
                        }
                    };
                }
            }
        }
        
        // Function to validate sales funnel reports from modal
        async function validateSalesFunnelFromModal() {
            if (!currentSchedulerName) {
                showToast('Error', 'No scheduler selected', 'error', 3000);
                return;
            }
            
            const btn = document.getElementById('validateSalesFunnelModalBtn');
            const resultsDiv = document.getElementById('salesFunnelValidationResults');
            
            // Disable button and show loading state
            if (btn) {
                btn.disabled = true;
                btn.textContent = '‚è≥ Validating...';
            }
            if (resultsDiv) {
                resultsDiv.innerHTML = '<div class="info-box" style="padding: 1rem; background: var(--gray-50); border-radius: 0.5rem; color: var(--gray-600);">Validating sales funnel report...</div>';
            }
            
            try {
                // Check cache first, then fetch if needed
                // Cache will be used automatically if valid (successful + match + same day)
                const response = await fetch('/api/validate-sales-funnel', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        scheduler_name: currentSchedulerName,
                        force_refresh: false,  // Use cache if available and valid
                        sso_token: getSsoToken()
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    // Use scheduler_record from API response, or fall back to current page data
                    const schedulerRecord = result.scheduler_record || currentSchedulerRecord;
                    // Use report.schedulerReport directly instead of scheduler_report_details
                    const schedulerReportDetails = result.report?.schedulerReport || {};
                    displaySingleSalesFunnelResults(result.validation, schedulerReportDetails, result.report, schedulerRecord, result.from_cache, result.stored_in_cache);
                    
                    // Update clear cache section visibility
                    const clearCacheInlineSection = document.getElementById('clearCacheInlineSection');
                    if (clearCacheInlineSection) {
                        if (result.from_cache || result.stored_in_cache) {
                            // Section will be shown by displaySingleSalesFunnelResults
                        } else {
                            clearCacheInlineSection.style.display = 'none';
                            clearCacheInlineSection.innerHTML = '';
                        }
                    }
                    
                    // Show toast with cache info if applicable
                    let toastMessage = `${currentSchedulerName} validated successfully`;
                    if (result.from_cache && result.fetched_at) {
                        const fetchedDate = new Date(result.fetched_at);
                        const timeStr = fetchedDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                        toastMessage += ` (from cache, fetched at ${timeStr})`;
                    }
                    showToast('Validation Complete', toastMessage, 'success', 3000);
                } else {
                    if (resultsDiv) {
                        let errorDetails = '';
                        
                        // Handle authentication errors first
                        if (result.auth_error) {
                            errorDetails = `
                                <div style="padding: 1.5rem; background: #fee2e2; border: 1px solid #ef4444; border-radius: 0.5rem; text-align: center;">
                                    <div style="font-size: 1.5rem; margin-bottom: 0.75rem;">üîí</div>
                                    <h4 style="margin: 0 0 0.5rem 0; font-size: 1rem; color: #991b1b; font-weight: 600;">Authentication Failed</h4>
                                    <p style="margin: 0; font-size: 0.875rem; color: #7f1d1d; line-height: 1.6;">
                                        <strong>Invalid SSO Token</strong>
                                    </p>
                                    <p style="margin: 0.75rem 0 0 0; font-size: 0.875rem; color: #991b1b; line-height: 1.6;">
                                        ${result.error || 'The SSO token provided is invalid or has expired. Please check your SSO token and try again.'}
                                    </p>
                                    <p style="margin: 0.75rem 0 0 0; font-size: 0.8rem; color: #7f1d1d;">
                                        Please update your SSO token in the settings and try again.
                                    </p>
                                </div>
                            `;
                            showToast('Authentication Error', 'Invalid SSO token. Please check your token and try again.', 'error', 5000);
                        } else if (result.empty_result) {
                            // Handle empty results with a user-friendly message
                            const todayDate = result.today_date || new Date().toISOString().split('T')[0];
                            errorDetails = `
                                <div style="padding: 1.5rem; background: #fef3c7; border: 1px solid #fbbf24; border-radius: 0.5rem; text-align: center;">
                                    <div style="font-size: 1.5rem; margin-bottom: 0.75rem;">üì≠</div>
                                    <h4 style="margin: 0 0 0.5rem 0; font-size: 1rem; color: #92400e; font-weight: 600;">No Data Found</h4>
                                    <p style="margin: 0; font-size: 0.875rem; color: #78350f; line-height: 1.6;">
                                        No sales funnel reports were found for <strong>${currentSchedulerName}</strong> for today's date (<strong>${todayDate}</strong>).
                                    </p>
                                    <p style="margin: 0.75rem 0 0 0; font-size: 0.8rem; color: #92400e;">
                                        The scheduler may not have run yet today, or the data may not be available in the database.
                                    </p>
                                </div>
                            `;
                            // Don't show error toast for empty results
                        } else {
                            // Regular error message
                            errorDetails = result.message || 'Failed to validate sales funnel report';
                            if (result.error) {
                                errorDetails += `<br><br><strong>Details:</strong><br><small style="font-family: monospace; white-space: pre-wrap;">${result.error}</small>`;
                            }
                            if (result.found_schedulers && result.found_schedulers.length > 0) {
                                errorDetails += `<br><br><strong>Found schedulers:</strong> ${result.found_schedulers.join(', ')}`;
                            }
                            if (result.found_reports !== undefined) {
                                errorDetails += `<br><strong>Total reports found:</strong> ${result.found_reports}`;
                            }
                            errorDetails = `
                                <div style="padding: 1rem; background: #fee2e2; border: 1px solid #f87171; border-radius: 0.5rem; color: #991b1b;">
                                    <strong>Error:</strong> ${errorDetails}
                                </div>
                            `;
                            // Show error toast only for actual errors (not empty results)
                            showToast('Validation Failed', result.message || 'Failed to validate report', 'error', 4000);
                        }
                        
                        resultsDiv.innerHTML = errorDetails;
                    }
                }
            } catch (error) {
                console.error('Error validating sales funnel:', error);
                if (resultsDiv) {
                    resultsDiv.innerHTML = `
                        <div class="info-box" style="padding: 1rem; background: #fee2e2; border-radius: 0.5rem; color: #991b1b;">
                            <strong>Error:</strong> ${error.message}
                        </div>
                    `;
                }
                showToast('Validation Error', 'Failed to validate sales funnel report', 'error', 4000);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'üîÑ Run Validation';
                }
            }
        }
        
        function formatTimestamp(timestamp) {
            if (!timestamp) return '-';
            const date = new Date(timestamp);
            return date.toLocaleString('en-US', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }
        
        function formatTimeOnly(timestamp) {
            if (!timestamp) return '-';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }
        
        function displaySingleSalesFunnelResults(validation, schedulerReportDetails, report, schedulerRecord, fromCache = false, storedInCache = false) {
            const resultsDiv = document.getElementById('salesFunnelValidationResults');
            
            if (!resultsDiv) return;
            
            if (!validation || typeof validation !== 'object') {
                resultsDiv.innerHTML = '<div class="info-box" style="padding: 1rem; background: var(--gray-50); border-radius: 0.5rem; color: var(--gray-600);">No validation results available.</div>';
                return;
            }
            
            const rowsInserted = validation.rows_inserted || 0;
            const expectedTotal = validation.expected_total || 0;
            const match = validation.match;
            const podCount = validation.pod_count || 0;
            const executionSuccess = validation.execution_success;
            const diff = validation.difference || 0;
            
            // Extract scheduler details from schedulerRecord
            let schedulerDetails = null;
            if (schedulerRecord) {
                const isPending = !schedulerRecord.executionStartDate && schedulerRecord.executionSuccess === undefined;
                const isInProgress = schedulerRecord.executionStartDate && !schedulerRecord.executionFinishDate;
                const isSuccess = schedulerRecord.executionSuccess === true;
                const isFailed = schedulerRecord.executionSuccess === false;
                
                let statusText, statusClass;
                if (isPending) {
                    statusText = 'Pending';
                    statusClass = 'status-pending';
                } else if (isInProgress) {
                    statusText = 'In Progress';
                    statusClass = 'status-in-progress';
                } else if (isSuccess) {
                    statusText = 'Success';
                    statusClass = 'status-success';
                } else {
                    statusText = 'Fail';
                    statusClass = 'status-fail';
                }
                
                // Calculate duration
                let duration = null;
                if (schedulerRecord.executionStartDate && schedulerRecord.executionFinishDate) {
                    const start = parseInt(schedulerRecord.executionStartDate);
                    const end = parseInt(schedulerRecord.executionFinishDate);
                    const diffMs = end - start;
                    const hours = Math.floor(diffMs / (1000 * 60 * 60));
                    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
                    duration = `${hours}h ${minutes}m ${seconds}s`;
                }
                
                schedulerDetails = {
                    status: statusText,
                    statusClass: statusClass,
                    startTime: schedulerRecord.executionStartDate ? formatTimeOnly(schedulerRecord.executionStartDate) : '-',
                    endTime: schedulerRecord.executionFinishDate ? formatTimeOnly(schedulerRecord.executionFinishDate) : '-',
                    duration: duration || '-',
                    bqDataFetch: schedulerRecord.bqTotalData !== undefined ? schedulerRecord.bqTotalData : '-',
                    savedData: schedulerRecord.analyticTotalData !== undefined ? schedulerRecord.analyticTotalData : '-'
                };
            }
            
            const statusColor = match ? '#d1fae5' : '#fee2e2';
            const statusTextColor = match ? '#065f46' : '#991b1b';
            
            // Calculate total duration from all pods
            let totalDurationMs = 0;
            let totalDurationFormatted = '-';
            if (schedulerReportDetails && Object.keys(schedulerReportDetails).length > 0) {
                Object.values(schedulerReportDetails).forEach(podData => {
                    if (podData && typeof podData === 'object' && podData.startTime && podData.endTime) {
                        const start = parseInt(podData.startTime);
                        const end = parseInt(podData.endTime);
                        if (!isNaN(start) && !isNaN(end)) {
                            totalDurationMs += (end - start);
                        }
                    }
                });
                
                if (totalDurationMs > 0) {
                    const hours = Math.floor(totalDurationMs / (1000 * 60 * 60));
                    const minutes = Math.floor((totalDurationMs % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((totalDurationMs % (1000 * 60)) / 1000);
                    totalDurationFormatted = `${hours}h ${minutes}m ${seconds}s`;
                }
            }
            
            // Calculate number of columns needed (removed Success, added Total Duration)
            const numColumns = 6; // Pods, Total Duration, Rows Inserted, SAVED DATA, Difference, Match
            
            // Build validation results HTML (shown after clicking validate)
            // Note: Scheduler details section is already shown above the validate button when modal opens
            let html = '';
            
            // Add validation metrics section
            html += `
                <div style="padding: 0.75rem; background: white; border: 1px solid var(--gray-200); border-radius: 0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 1rem;">
                    <div style="display: grid; grid-template-columns: repeat(${numColumns}, 1fr); gap: 0.75rem; align-items: center;">
                        <div style="text-align: center;">
                            <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Pods</div>
                            <div style="font-size: 1rem; font-weight: 600; color: var(--gray-900);">${podCount}</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Total Duration</div>
                            <div style="font-size: 1rem; font-weight: 600; color: var(--gray-900);">${totalDurationFormatted}</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Rows Inserted</div>
                            <div style="font-size: 1rem; font-weight: 600; color: var(--gray-900);">${rowsInserted.toLocaleString()}</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">SAVED DATA</div>
                            <div style="font-size: 1rem; font-weight: 600; color: var(--gray-900);">${expectedTotal > 0 ? expectedTotal.toLocaleString() : '<span style="color: var(--gray-400);">-</span>'}</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Difference</div>
                            <div style="font-size: 1rem; font-weight: 600; color: ${diff > 0 ? '#059669' : diff < 0 ? '#dc2626' : 'var(--gray-600)'};">
                                ${diff > 0 ? '+' : ''}${diff.toLocaleString()}
                            </div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.7rem; color: var(--gray-600); margin-bottom: 0.125rem;">Match</div>
                            <div style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; display: inline-block; font-size: 0.75rem; font-weight: 600; background: ${statusColor}; color: ${statusTextColor};">
                                ${match ? '‚úì YES' : '‚úó NO'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Display scheduler report details (all pods)
            if (schedulerReportDetails && Object.keys(schedulerReportDetails).length > 0) {
                html += `
                    <div style="padding: 0.75rem; background: white; border: 1px solid var(--gray-200); border-radius: 0.5rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 0.75rem 0; font-size: 0.875rem; font-weight: 600; color: var(--gray-900);">Scheduler Report Details (All Pods)</h3>
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: var(--gray-50);">
                                        <th style="padding: 0.5rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: var(--gray-700); border-bottom: 1px solid var(--gray-200);">Scheduler No</th>
                                        <th style="padding: 0.5rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: var(--gray-700); border-bottom: 1px solid var(--gray-200);">Start Time</th>
                                        <th style="padding: 0.5rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: var(--gray-700); border-bottom: 1px solid var(--gray-200);">End Time</th>
                                        <th style="padding: 0.5rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: var(--gray-700); border-bottom: 1px solid var(--gray-200);">Duration</th>
                                        <th style="padding: 0.5rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: var(--gray-700); border-bottom: 1px solid var(--gray-200);">Rows Inserted</th>
                                        <th style="padding: 0.5rem; text-align: left; font-size: 0.75rem; font-weight: 600; color: var(--gray-700); border-bottom: 1px solid var(--gray-200);">Execution Success</th>
                                    </tr>
                                </thead>
                                <tbody>
            `;
                
                // Sort pods by schedulerNo (schedulerReportDetails is now report.schedulerReport)
                const sortedPods = Object.entries(schedulerReportDetails).sort((a, b) => {
                    const aNo = a[1]?.schedulerNo ?? 0;
                    const bNo = b[1]?.schedulerNo ?? 0;
                    return aNo - bNo;
                });
                
                sortedPods.forEach(([podKey, podData]) => {
                    if (!podData || typeof podData !== 'object') return;
                    
                    const podSuccess = podData.executionSuccess;
                    const podSuccessColor = podSuccess ? '#d1fae5' : '#fee2e2';
                    const podSuccessTextColor = podSuccess ? '#065f46' : '#991b1b';
                    
                    // Calculate duration for this pod
                    let podDuration = '-';
                    if (podData.startTime && podData.endTime) {
                        const start = parseInt(podData.startTime);
                        const end = parseInt(podData.endTime);
                        if (!isNaN(start) && !isNaN(end)) {
                            const diffMs = end - start;
                            const hours = Math.floor(diffMs / (1000 * 60 * 60));
                            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
                            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
                            podDuration = `${hours}h ${minutes}m ${seconds}s`;
                        }
                    }
                    
                    html += `
                        <tr style="border-bottom: 1px solid var(--gray-100);">
                            <td style="padding: 0.5rem; font-size: 0.875rem; color: var(--gray-900);">${podData.schedulerNo !== undefined ? podData.schedulerNo : '-'}</td>
                            <td style="padding: 0.5rem; font-size: 0.875rem; color: var(--gray-900); font-family: monospace;">${formatTimeOnly(podData.startTime)}</td>
                            <td style="padding: 0.5rem; font-size: 0.875rem; color: var(--gray-900); font-family: monospace;">${formatTimeOnly(podData.endTime)}</td>
                            <td style="padding: 0.5rem; font-size: 0.875rem; color: var(--gray-900);">${podDuration}</td>
                            <td style="padding: 0.5rem; font-size: 0.875rem; color: var(--gray-900); font-weight: 600;">${podData.rowsInserted !== undefined ? podData.rowsInserted.toLocaleString() : '-'}</td>
                            <td style="padding: 0.5rem; font-size: 0.875rem;">
                                <span style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; background: ${podSuccessColor}; color: ${podSuccessTextColor};">
                                    ${podSuccess ? '‚úì YES' : '‚úó NO'}
                                </span>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = html;
            
            // Add Clear Cache button inline with Run Validation button if result is from cache or stored in cache
            const clearCacheInlineSection = document.getElementById('clearCacheInlineSection');
            if (clearCacheInlineSection && (fromCache || storedInCache)) {
                const buttonBg = fromCache ? '#f59e0b' : '#059669';
                const buttonHoverBg = fromCache ? '#d97706' : '#047857';
                
                clearCacheInlineSection.innerHTML = `
                    <button id="clearCacheBtn" onclick="clearSalesFunnelCache('${currentSchedulerName}')" 
                            style="padding: 0.6rem 1rem; background: ${buttonBg}; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500; font-size: 0.875rem; white-space: nowrap; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.5rem; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                            onmouseover="this.style.background='${buttonHoverBg}'; this.style.transform='translateY(-1px)'"
                            onmouseout="this.style.background='${buttonBg}'; this.style.transform='translateY(0)'">
                        <span>üóëÔ∏è</span>
                        <span>Clear Cache</span>
                    </button>
                `;
                clearCacheInlineSection.style.display = 'flex';
            } else if (clearCacheInlineSection) {
                clearCacheInlineSection.style.display = 'none';
                clearCacheInlineSection.innerHTML = '';
            }
        }
        
        // Function to refresh data by triggering the Python script
        async function refreshData() {
            const btn = document.getElementById('refreshDataBtn');
            const icon = document.getElementById('refreshIcon');
            const text = document.getElementById('refreshText');
            
            // Check if we're on Today's Report page
            const isTodayReport = document.getElementById('today-report-section')?.classList.contains('active');
            const endpoint = '/api/refresh-today';
            const defaultText = 'Refresh today data';
            
            // Disable button and show loading state
            btn.disabled = true;
            icon.textContent = '‚è≥';
            text.textContent = 'Refreshing...';
            
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sso_token: getSsoToken() })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    // Update last updated time
                    updateLastUpdatedTime(true);
                    
                    const recordCount = result.today_records || 0;
                    
                    // Show toast notification
                    showToast(
                        'Data Refreshed Successfully',
                        `${recordCount} job${recordCount !== 1 ? 's' : ''} updated`,
                        'success',
                        5000
                    );
                    
                    // Show success message on button
                    icon.textContent = '‚úÖ';
                    text.textContent = `Refreshed! (${recordCount} records)`;
                    
                    // Reload data after a short delay
                    setTimeout(async () => {
                        const dataLoaded = await loadData();
                        if (dataLoaded) {
                            // Re-initialize dashboard with new data
                            init();
                            icon.textContent = 'üîÑ';
                            text.textContent = defaultText;
                        } else {
                            icon.textContent = '‚ùå';
                            text.textContent = 'Refresh Failed';
                        }
                        btn.disabled = false;
                    }, 500);
                } else {
                    // Clear data on error
                    TODAY_DATA = [];
                    initTodayReport();
                    
                    // Show last updated time as "-"
                    const lastUpdatedEl = document.getElementById('lastUpdatedTime');
                    if (lastUpdatedEl) {
                        lastUpdatedEl.textContent = 'Last updated: -';
                        lastUpdatedEl.style.display = 'inline';
                    }
                    
                    // Check for different types of errors
                    const errorMessage = result.message || '';
                    const errorOutput = result.output || '';
                    const errorText = result.error || '';
                    const fullErrorText = (errorMessage + ' ' + errorOutput + ' ' + errorText).toLowerCase();
                    
                    // Check if error is related to VPN/network connectivity
                    const isVpnError = fullErrorText.includes('could not resolve host') ||
                                     fullErrorText.includes('could not resolve host: database-explorer.gdn-app.com') ||
                                     fullErrorText.includes('return code: 6') ||
                                     fullErrorText.includes('curl: (6)');
                    
                    // Check if error is related to invalid token
                    const isTokenError = errorMessage.includes('Invalid cookie or header token') ||
                                        errorMessage.includes('Invalid Cookie or header token') ||
                                        errorOutput.includes('Invalid cookie or header token') ||
                                        errorOutput.includes('Invalid Cookie or header token') ||
                                        errorText.includes('Invalid cookie or header token') ||
                                        errorText.includes('Invalid Cookie or header token');
                    
                    if (isVpnError) {
                        // Show VPN connection error toast
                        showToast(
                            'VPN Connection Required',
                            'Could not connect to database. Please check your VPN connection and try again.',
                            'error',
                            8000
                        );
                    } else if (isTokenError) {
                        // Show SSO token modal
                        showSsoTokenModal();
                    } else {
                        // Show generic error toast
                        showToast(
                            'Refresh Failed',
                            result.message || 'Failed to refresh today\'s data',
                            'error',
                            6000
                        );
                    }
                    
                    // Show error message on button
                    icon.textContent = '‚ùå';
                    text.textContent = 'Refresh Failed';
                    
                    setTimeout(() => {
                        icon.textContent = 'üîÑ';
                        text.textContent = defaultText;
                        btn.disabled = false;
                    }, 3000);
                }
            } catch (error) {
                console.error('Error refreshing data:', error);
                
                // Clear data on error
                TODAY_DATA = [];
                initTodayReport();
                
                // Show last updated time as "-"
                const lastUpdatedEl = document.getElementById('lastUpdatedTime');
                if (lastUpdatedEl) {
                    lastUpdatedEl.textContent = 'Last updated: -';
                    lastUpdatedEl.style.display = 'inline';
                }
                
                // Check if error message contains token error (unlikely in catch, but check anyway)
                const errorMessage = (error.message || error.toString() || '').toLowerCase();
                const isTokenError = errorMessage.includes('invalid cookie or header token');
                
                // Check for network/VPN errors in catch block (e.g., fetch failures)
                const isNetworkError = errorMessage.includes('failed to fetch') ||
                                      errorMessage.includes('networkerror') ||
                                      errorMessage.includes('network error');
                
                if (isTokenError) {
                    // Show SSO token modal
                    showSsoTokenModal();
                } else if (isNetworkError) {
                    // Show VPN connection error toast
                    showToast(
                        'Network Connection Error',
                        'Unable to connect to server. Please check your VPN connection and try again.',
                        'error',
                        8000
                    );
                } else {
                    // Show generic error toast
                    showToast(
                        'Connection Error',
                        'Make sure you\'re using the Python server (python3 server.py)',
                        'error',
                        6000
                    );
                }
                
                icon.textContent = '‚ùå';
                text.textContent = 'Error';
                
                setTimeout(() => {
                    icon.textContent = 'üîÑ';
                    text.textContent = defaultText;
                    btn.disabled = false;
                }, 3000);
            }
        }
        
        // Global variables
        let filteredJobs = [];
        let filteredReports = [];
        let jobSort = { field: 'name', direction: 'asc' };
        let reportSort = { column: null, direction: 'asc' };
        
        let pageTitles = {
            'jobs': 'Rundeck Jobs',
            'today-report': "Today's Report",
            'reports-overview': 'Reports Overview',
            'reports-patterns': 'Pattern Analysis',
            'reports-data': 'All Scheduler Data'
        };
        
        // Navigation
        function navigateTo(page) {
            // Update nav items
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            event.target.closest('.nav-item').classList.add('active');
            
            // Update sections
            document.querySelectorAll('.page-section').forEach(section => section.classList.remove('active'));
            document.getElementById(`${page}-section`).classList.add('active');
            
            // Update title
            document.getElementById('pageTitle').textContent = pageTitles[page] || 'Dashboard';
            
            // Show/hide shared reports header based on page
            const reportsHeader = document.getElementById('reportsHeader');
            const isReportsPage = ['reports-overview', 'reports-patterns', 'reports-data'].includes(page);
            
            if (reportsHeader) {
                reportsHeader.style.display = isReportsPage ? 'block' : 'none';
            }
            
            // Load last updated time for reports pages
            if (isReportsPage) {
                loadPastDataLastUpdatedTime();
            }
            
            // Show/hide refresh button based on page
            const refreshBtn = document.getElementById('refreshDataBtn');
            const refreshText = document.getElementById('refreshText');
            
            if (refreshBtn) {
                // Show button only on Today's Report page
                if (page === 'today-report') {
                    refreshBtn.style.display = 'inline-flex';
                    if (refreshText) {
                        refreshText.textContent = 'Refresh today data';
                    }
                    // Show refresh button container
                    const refreshContainer = document.getElementById('refreshButtonContainer');
                    if (refreshContainer) {
                        refreshContainer.style.display = 'flex';
                    }
                    // Show last updated time
                    loadLastUpdatedTime(true);
                } else {
                    // Hide Today's Report refresh button on other pages
                    refreshBtn.style.display = 'none';
                    // Hide refresh button container
                    const refreshContainer = document.getElementById('refreshButtonContainer');
                    if (refreshContainer) {
                        refreshContainer.style.display = 'none';
                    }
                }
            }
        }
        
        // Utility Functions
        function formatTime(hour, minute, seconds) {
            if (hour.includes(',')) {
                const hours = hour.split(',');
                const times = hours.map(h => `${h.padStart(2, '0')}:${minute.padStart(2, '0')}`);
                return times.join(', ');
            }
            return `${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
        }
        
        function formatDate(epoch) {
            if (!epoch) return 'N/A';
            return new Date(parseInt(epoch)).toLocaleDateString('en-US', {
                weekday: 'short', month: 'short', day: 'numeric', year: 'numeric'
            });
        }
        
        function formatDateShort(epoch) {
            if (!epoch) return 'N/A';
            return new Date(parseInt(epoch)).toLocaleDateString('en-US', {
                month: 'short', day: 'numeric', year: 'numeric'
            });
        }
        
        function formatDateTime(epoch) {
            if (!epoch) return '-';
            return new Date(parseInt(epoch)).toLocaleString('en-US', {
                month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
        }
        
        function formatTimeOnly(epoch) {
            if (!epoch) return '-';
            return new Date(parseInt(epoch)).toLocaleString('en-US', {
                hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
            });
        }
        
        function formatDuration(seconds) {
            if (!seconds || seconds === 0) return '-';
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
        }
        
        function calculateDuration(startEpoch, endEpoch) {
            if (!startEpoch || !endEpoch) return null;
            const start = parseInt(startEpoch);
            const end = parseInt(endEpoch);
            const durationMs = end - start;
            const totalSeconds = Math.floor(durationMs / 1000);
            return { totalSeconds, formatted: formatDuration(totalSeconds) };
        }
        
        function getStatus(s) {
            if (s.executionSuccess === true) return 'success';
            if (s.executionSuccess === false) return 'failed';
            if (s.executionStartDate && !s.executionFinishDate) return 'running';
            return 'failed';
        }
        
        // Jobs Functions
        function populateTabFilter() {
            const tabFilter = document.getElementById('tabFilter');
            if (!tabFilter) return;
            
            // Get unique tab values from JOBS_DATA
            const uniqueTabs = [...new Set(JOBS_DATA.map(job => job.tab).filter(tab => tab !== null && tab !== undefined))].sort();
            
            // Clear existing options except "All"
            tabFilter.innerHTML = '<option value="All">All</option>';
            
            // Add unique tab values
            uniqueTabs.forEach(tab => {
                const option = document.createElement('option');
                option.value = tab;
                option.textContent = tab;
                tabFilter.appendChild(option);
            });
            
            // Add "None" option for jobs without a tab
            if (JOBS_DATA.some(job => !job.tab)) {
                const noneOption = document.createElement('option');
                noneOption.value = 'None';
                noneOption.textContent = 'None';
                tabFilter.appendChild(noneOption);
            }
        }
        
        function updateJobsStats() {
            const dailyEnabled = JOBS_DATA.filter(j => j.frequency === 'Daily' && j.scheduleEnabled).length;
            const weeklyEnabled = JOBS_DATA.filter(j => j.frequency === 'Weekly' && j.scheduleEnabled).length;
            const monthlyEnabled = JOBS_DATA.filter(j => j.frequency === 'Monthly' && j.scheduleEnabled).length;
            const totalJobs = JOBS_DATA.length;
            const totalEnabled = JOBS_DATA.filter(j => j.scheduleEnabled).length;
            
            // Count Canary and Non-Canary jobs (only enabled)
            const canaryJobs = JOBS_DATA.filter(j => j.scheduleEnabled && j.curlCommand && j.curlCommand.includes('seller-insights-next.gdn-sg.cld')).length;
            const nonCanaryJobs = JOBS_DATA.filter(j => j.scheduleEnabled && j.curlCommand && j.curlCommand.includes('seller-insights.gdn-sg.cld')).length;
            
            document.getElementById('dailyJobs').textContent = dailyEnabled;
            document.getElementById('weeklyJobs').textContent = weeklyEnabled;
            document.getElementById('monthlyJobs').textContent = monthlyEnabled;
            document.getElementById('totalJobs').textContent = totalJobs;
            document.getElementById('enabledJobs').textContent = totalEnabled;
            document.getElementById('canaryJobs').textContent = canaryJobs;
            document.getElementById('nonCanaryJobs').textContent = nonCanaryJobs;
        }
        
        function clearJobSearch() {
            const searchInput = document.getElementById('jobSearch');
            searchInput.value = '';
            updateSearchClearButton('jobSearch');
            renderJobsTable();
        }
        
        function updateSearchClearButton(inputId) {
            const input = document.getElementById(inputId);
            const clearBtn = input.parentElement.querySelector('.search-clear-btn');
            if (clearBtn) {
                if (input.value.trim() !== '') {
                    clearBtn.classList.add('visible');
                } else {
                    clearBtn.classList.remove('visible');
                }
            }
        }
        
        function renderJobsTable() {
            const search = document.getElementById('jobSearch').value.toLowerCase();
            const frequency = document.getElementById('frequencyFilter').value;
            const status = document.getElementById('jobStatusFilter').value;
            const environment = document.getElementById('environmentFilter').value;
            const tab = document.getElementById('tabFilter') ? document.getElementById('tabFilter').value : 'All';
            
            filteredJobs = JOBS_DATA.filter(job => {
                const matchesSearch = job.name.toLowerCase().includes(search) || 
                                     job.analyticName.toLowerCase().includes(search);
                const matchesFrequency = frequency === 'All' || job.frequency === frequency;
                const matchesStatus = status === 'All' || 
                                     (status === 'Enabled' && job.scheduleEnabled) ||
                                     (status === 'Disabled' && !job.scheduleEnabled);
                
                // Environment filter
                let matchesEnvironment = true;
                if (environment !== 'All') {
                    if (environment === 'Canary') {
                        matchesEnvironment = job.curlCommand && job.curlCommand.includes('seller-insights-next.gdn-sg.cld');
                    } else if (environment === 'Non-Canary') {
                        matchesEnvironment = job.curlCommand && job.curlCommand.includes('seller-insights.gdn-sg.cld');
                    }
                }
                
                // Tab filter
                const matchesTab = tab === 'All' || job.tab === tab || (tab === 'None' && !job.tab);
                
                return matchesSearch && matchesFrequency && matchesStatus && matchesEnvironment && matchesTab;
            });
            
            // Sort the filtered jobs
            filteredJobs.sort((a, b) => {
                let aVal, bVal;
                switch(jobSort.field) {
                    case 'name':
                        aVal = a.analyticName.toLowerCase();
                        bVal = b.analyticName.toLowerCase();
                        break;
                    case 'time':
                        aVal = parseInt(a.hour) * 3600 + parseInt(a.minute) * 60 + parseInt(a.seconds);
                        bVal = parseInt(b.hour) * 3600 + parseInt(b.minute) * 60 + parseInt(b.seconds);
                        break;
                    case 'frequency':
                        aVal = a.frequency.toLowerCase();
                        bVal = b.frequency.toLowerCase();
                        break;
                    case 'status':
                        aVal = a.scheduleEnabled ? 1 : 0;
                        bVal = b.scheduleEnabled ? 1 : 0;
                        break;
                    case 'environment':
                        aVal = (a.curlCommand && a.curlCommand.includes('seller-insights-next.gdn-sg.cld')) ? 'canary' : 'non-canary';
                        bVal = (b.curlCommand && b.curlCommand.includes('seller-insights-next.gdn-sg.cld')) ? 'canary' : 'non-canary';
                        break;
                    default:
                        return 0;
                }
                
                if (aVal < bVal) return jobSort.direction === 'asc' ? -1 : 1;
                if (aVal > bVal) return jobSort.direction === 'asc' ? 1 : -1;
                return 0;
            });
            
            // Update result count display
            document.getElementById('jobsResultCount').textContent = filteredJobs.length;
            document.getElementById('jobsTotalCount').textContent = JOBS_DATA.length;
            
            const tbody = document.getElementById('jobsTableBody');
            
            if (filteredJobs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="no-results">No jobs found</td></tr>';
                // Count is already updated above, so just return
                return;
            }
            
            tbody.innerHTML = filteredJobs.map(job => {
                const scheduleTime = formatTime(job.hour, job.minute, job.seconds);
                const statusBadge = job.scheduleEnabled ? 
                    '<span class="badge badge-success">Enabled</span>' : 
                    '<span class="badge badge-secondary">Disabled</span>';
                
                // Detect environment from curlCommand
                let environmentBadge = '<span class="badge badge-secondary">Unknown</span>';
                if (job.curlCommand) {
                    if (job.curlCommand.includes('seller-insights-next.gdn-sg.cld')) {
                        environmentBadge = '<span class="badge badge-warning" style="background: #fef3c7; color: #92400e; font-weight: 700;">üü° Canary</span>';
                    } else if (job.curlCommand.includes('seller-insights.gdn-sg.cld')) {
                        environmentBadge = '<span class="badge badge-info" style="background: #dbeafe; color: #1e40af; font-weight: 700;">üîµ Non-Canary</span>';
                    }
                }
                
                // Split times into multiple lines if comma-separated
                const times = scheduleTime.split(', ');
                const timeDisplay = times.length > 1 ? 
                    times.map(t => `<div>${t}</div>`).join('') : 
                    scheduleTime;
                
                // Escape quotes in job name for onclick
                const escapedJobName = job.name.replace(/'/g, "\\'");
                
                // Get tab display for analyticName
                const tabDisplay = job.tab ? `<div style="color: var(--gray-600); font-size: 0.75rem; font-weight: 500;">Tab: <span style="color: var(--gray-900);">${job.tab}</span></div>` : '';
                
                // Get tab display for Tab column
                const tabColumnDisplay = job.tab ? `<span style="font-weight: 600; color: var(--gray-700);">${job.tab}</span>` : '<span style="color: var(--gray-400);">-</span>';
                
                // Combine frequency and dayInfo - display dayInfo on next line
                const frequencyDayInfo = job.dayInfo ? 
                    `<div style="display: flex; flex-direction: column; gap: 0.25rem;">
                        <div>${job.frequency}</div>
                        <div style="color: var(--gray-600); font-size: 0.75rem;">${job.dayInfo}</div>
                    </div>` : 
                    job.frequency;
                
                // Make analyticName clickable only if BQ Details are available
                const hasBqDetails = job.bqDetails && job.bqDetails.source;
                const analyticNameClickHandler = hasBqDetails ? 
                    `showBqDetailsModal('${escapedJobName}')` : 
                    '';
                const analyticNameTitle = hasBqDetails ? 
                    'Click to view BQ Details' : 
                    '';
                const analyticNameClass = hasBqDetails ? 
                    'clickable-analytic-name-bq' : 
                    '';
                const onclickAttr = hasBqDetails ? `onclick="${analyticNameClickHandler}"` : '';
                const titleAttr = hasBqDetails ? `title="${analyticNameTitle}"` : '';
                
                // Combine analyticName with tab below
                const analyticNameWithTab = `<div style="display: flex; flex-direction: column; gap: 0.25rem;">
                    <strong class="${analyticNameClass}" ${titleAttr} ${onclickAttr}>${job.analyticName}</strong>
                    ${tabDisplay}
                </div>`;
                
                return `
                    <tr>
                        <td>${analyticNameWithTab}</td>
                        <td>${timeDisplay}</td>
                        <td>${frequencyDayInfo}</td>
                        <td>${statusBadge}</td>
                        <td>${environmentBadge}</td>
                        <td>
                            <button class="action-btn-icon" onclick="showCurlModal('${escapedJobName}')" title="View Details">
                                üëÅÔ∏è
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        let currentJobsHeatmapTryFilter = 'All';
        let currentJobsHeatmapStatusFilter = 'Enabled';
        let currentJobsHeatmapEnvironmentFilter = 'All';
        
        function getJobEnvironment(job) {
            if (!job.curlCommand) return 'Unknown';
            if (job.curlCommand.includes('seller-insights-next.gdn-sg.cld')) return 'Canary';
            if (job.curlCommand.includes('seller-insights.gdn-sg.cld')) return 'Non-Canary';
            return 'Unknown';
        }
        
        function filterJobsHeatmapByTry(tryFilter) {
            currentJobsHeatmapTryFilter = tryFilter;
            
            // Update try filter button styles
            document.querySelectorAll('[id^="jobs-heatmap-all-tries"], [id^="jobs-heatmap-try-"]').forEach(btn => {
                btn.style.background = 'white';
                btn.style.color = 'var(--gray-700)';
            });
            
            const activeBtn = document.getElementById(`jobs-heatmap-${tryFilter === 'All' ? 'all-tries' : `try-${tryFilter}`}`);
            if (activeBtn) {
                activeBtn.style.background = 'var(--primary)';
                activeBtn.style.color = 'white';
            }
            
            // Re-render heatmap with filters
            renderJobsHeatmap(currentJobsHeatmapTryFilter, currentJobsHeatmapStatusFilter, currentJobsHeatmapEnvironmentFilter);
        }
        
        function filterJobsHeatmapByStatus(statusFilter) {
            currentJobsHeatmapStatusFilter = statusFilter;
            
            // Update status filter button styles
            document.querySelectorAll('[id^="jobs-heatmap-status-"]').forEach(btn => {
                btn.style.background = 'white';
                btn.style.color = 'var(--gray-700)';
            });
            
            const activeBtn = document.getElementById(`jobs-heatmap-status-${statusFilter.toLowerCase()}`);
            if (activeBtn) {
                activeBtn.style.background = 'var(--primary)';
                activeBtn.style.color = 'white';
            }
            
            // Re-render heatmap with filters
            renderJobsHeatmap(currentJobsHeatmapTryFilter, currentJobsHeatmapStatusFilter, currentJobsHeatmapEnvironmentFilter);
        }
        
        function filterJobsHeatmapByEnvironment(environmentFilter) {
            currentJobsHeatmapEnvironmentFilter = environmentFilter;
            
            // Update environment filter button styles
            document.querySelectorAll('[id^="jobs-heatmap-env-"]').forEach(btn => {
                btn.style.background = 'white';
                btn.style.color = 'var(--gray-700)';
            });
            
            let activeBtnId;
            if (environmentFilter === 'All') {
                activeBtnId = 'jobs-heatmap-env-all';
            } else if (environmentFilter === 'Canary') {
                activeBtnId = 'jobs-heatmap-env-canary';
            } else if (environmentFilter === 'Non-Canary') {
                activeBtnId = 'jobs-heatmap-env-noncanary';
            }
            
            const activeBtn = document.getElementById(activeBtnId);
            if (activeBtn) {
                activeBtn.style.background = 'var(--primary)';
                activeBtn.style.color = 'white';
            }
            
            // Re-render heatmap with filters
            renderJobsHeatmap(currentJobsHeatmapTryFilter, currentJobsHeatmapStatusFilter, currentJobsHeatmapEnvironmentFilter);
        }
        
        function renderJobsHeatmap(tryFilter = 'All', statusFilter = 'All', environmentFilter = 'All') {
            const frequencies = ['Daily', 'Weekly', 'Monthly', 'All Jobs'];
            
            // Group jobs by hour
            const jobsByHour = [];
            for (let h = 0; h < 24; h++) {
                jobsByHour[h] = {
                    Daily: { enabled: [], disabled: [] },
                    Weekly: { enabled: [], disabled: [] },
                    Monthly: { enabled: [], disabled: [] },
                    'All Jobs': { enabled: [], disabled: [] }
                };
            }
            
            // Populate the jobsByHour structure
            JOBS_DATA.forEach(job => {
                const hourString = job.hour || '0';
                const hours = hourString.split(',').map(h => parseInt(h.trim()));
                
                // Filter by try number if specified
                let hoursToProcess = hours;
                if (tryFilter !== 'All') {
                    const tryIndex = parseInt(tryFilter) - 1; // Convert to 0-based index
                    if (tryIndex >= 0 && tryIndex < hours.length) {
                        // Only include the hour at this try position
                        hoursToProcess = [hours[tryIndex]];
                    } else {
                        // Job doesn't have this many tries, skip it
                        hoursToProcess = [];
                    }
                }
                
                hoursToProcess.forEach(hour => {
                    // Filter by status if specified
                    if (statusFilter !== 'All') {
                        const isEnabled = job.scheduleEnabled === true;
                        if (statusFilter === 'Enabled' && !isEnabled) return;
                        if (statusFilter === 'Disabled' && isEnabled) return;
                    }
                    
                    // Filter by environment if specified
                    if (environmentFilter !== 'All') {
                        const jobEnv = getJobEnvironment(job);
                        if (environmentFilter === 'Canary' && jobEnv !== 'Canary') return;
                        if (environmentFilter === 'Non-Canary' && jobEnv !== 'Non-Canary') return;
                    }
                    
                    const category = job.scheduleEnabled ? 'enabled' : 'disabled';
                    jobsByHour[hour][job.frequency][category].push(job);
                    jobsByHour[hour]['All Jobs'][category].push(job);
                });
            });
            
            // Find max jobs in any hour for opacity scaling
            let maxJobs = 0;
            jobsByHour.forEach(hour => {
                frequencies.forEach(freq => {
                    const total = hour[freq].enabled.length + hour[freq].disabled.length;
                    if (total > maxJobs) maxJobs = total;
                });
            });
            
            let html = '<div class="heatmap-container">';
            
            // Add header row with hour labels
            html += '<div class="heatmap-row">';
            html += '<div class="heatmap-label" style="font-weight: 600; color: var(--gray-700);">Frequency</div>';
            for (let h = 0; h < 24; h++) {
                html += `<div class="heatmap-cell" style="background: transparent; font-weight: 600; font-size: 0.75rem; color: var(--gray-700); padding: 0.25rem 0;">${h}</div>`;
            }
            html += '</div>';
            
            frequencies.forEach(freq => {
                html += '<div class="heatmap-row">';
                html += `<div class="heatmap-label">${freq}</div>`;
                
                for (let h = 0; h < 24; h++) {
                    const hourData = jobsByHour[h][freq];
                    let enabledCount = hourData.enabled.length;
                    let disabledCount = hourData.disabled.length;
                    
                    const total = enabledCount + disabledCount;
                    
                    if (total === 0) {
                        html += '<div class="heatmap-cell empty" title="No jobs scheduled"></div>';
                    } else {
                        // Color based on status filter and enabled vs disabled ratio
                        let bgColor;
                        if (statusFilter === 'Enabled') {
                            bgColor = '#10b981'; // Green for enabled only
                        } else if (statusFilter === 'Disabled') {
                            bgColor = '#9ca3af'; // Gray for disabled only
                        } else {
                            // Mixed: Color based on enabled vs disabled ratio
                            const enabledRatio = enabledCount / total;
                            bgColor = enabledRatio > 0.5 ? '#10b981' : enabledRatio > 0 ? '#f59e0b' : '#9ca3af';
                        }
                        
                        // Opacity based on count
                        const opacity = 0.3 + (Math.min(total, maxJobs) / maxJobs) * 0.7;
                        
                        html += `<div class="heatmap-cell" style="background: ${bgColor}; opacity: ${opacity}; cursor: pointer;" 
                                 onclick="showJobsAtHour(${h}, '${freq}')"
                                 title="Click to see jobs scheduled at ${h.toString().padStart(2, '0')}:00\\n${freq}: ${total} job(s)\\nEnabled: ${enabledCount}, Disabled: ${disabledCount}">
                                 ${total}
                                 </div>`;
                    }
                }
                html += '</div>';
            });
            
            html += '</div>';
            
            // Add detailed job list section
            html += `
                <div id="jobsAtHourDetails" style="margin-top: 1.5rem; padding: 1rem; background: var(--gray-50); border-radius: 0.5rem; display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h4 style="margin: 0; font-size: 1rem; color: var(--gray-900);" id="jobsAtHourTitle">Jobs at Hour</h4>
                        <button onclick="hideJobsAtHour()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--gray-600);" title="Close">&times;</button>
                    </div>
                    <div id="jobsAtHourList"></div>
                </div>
            `;
            
            document.getElementById('jobsHeatmapContainer').innerHTML = html;
        }
        
        function showJobsAtHour(hour, frequency) {
            // Filter jobs that are scheduled at this hour (checking comma-separated hours)
            const jobsByHour = JOBS_DATA.filter(job => {
                const hourString = job.hour || '0';
                const hours = hourString.split(',').map(h => parseInt(h.trim()));
                
                // Apply try filter if active
                if (currentJobsHeatmapTryFilter !== 'All') {
                    const tryIndex = parseInt(currentJobsHeatmapTryFilter) - 1; // Convert to 0-based index
                    if (tryIndex >= 0 && tryIndex < hours.length) {
                        // Only match if this hour is at the try position
                        return hours[tryIndex] === hour;
                    }
                    return false;
                }
                
                return hours.includes(hour);
            });
            
            // Apply status filter if active
            let statusFilteredJobs = jobsByHour;
            if (currentJobsHeatmapStatusFilter !== 'All') {
                statusFilteredJobs = jobsByHour.filter(job => {
                    const isEnabled = job.scheduleEnabled === true;
                    if (currentJobsHeatmapStatusFilter === 'Enabled') return isEnabled;
                    if (currentJobsHeatmapStatusFilter === 'Disabled') return !isEnabled;
                    return true;
                });
            }
            
            // Apply environment filter if active
            let environmentFilteredJobs = statusFilteredJobs;
            if (currentJobsHeatmapEnvironmentFilter !== 'All') {
                environmentFilteredJobs = statusFilteredJobs.filter(job => {
                    const jobEnv = getJobEnvironment(job);
                    if (currentJobsHeatmapEnvironmentFilter === 'Canary') return jobEnv === 'Canary';
                    if (currentJobsHeatmapEnvironmentFilter === 'Non-Canary') return jobEnv === 'Non-Canary';
                    return true;
                });
            }
            
            const filteredJobs = frequency === 'All Jobs' ? environmentFilteredJobs : environmentFilteredJobs.filter(j => j.frequency === frequency);
            
            if (filteredJobs.length === 0) {
                return;
            }
            
            // Sort by enabled status first, then by name
            filteredJobs.sort((a, b) => {
                if (a.scheduleEnabled !== b.scheduleEnabled) {
                    return b.scheduleEnabled ? 1 : -1;
                }
                return a.analyticName.localeCompare(b.analyticName);
            });
            
            const detailsSection = document.getElementById('jobsAtHourDetails');
            const titleElem = document.getElementById('jobsAtHourTitle');
            const listElem = document.getElementById('jobsAtHourList');
            
            const tryFilterText = currentJobsHeatmapTryFilter !== 'All' ? ` (${currentJobsHeatmapTryFilter}${currentJobsHeatmapTryFilter === '1' ? 'st' : currentJobsHeatmapTryFilter === '2' ? 'nd' : currentJobsHeatmapTryFilter === '3' ? 'rd' : 'th'} Try)` : '';
            const statusFilterText = currentJobsHeatmapStatusFilter !== 'All' ? ` - ${currentJobsHeatmapStatusFilter}` : '';
            const envFilterText = currentJobsHeatmapEnvironmentFilter !== 'All' ? ` - ${currentJobsHeatmapEnvironmentFilter}` : '';
            titleElem.textContent = `üìã ${frequency} Jobs Scheduled at ${hour.toString().padStart(2, '0')}:00${tryFilterText}${statusFilterText}${envFilterText} (${filteredJobs.length} job${filteredJobs.length > 1 ? 's' : ''})`;
            
            let html = '<div style="display: grid; gap: 0.5rem;">';
            filteredJobs.forEach(job => {
                const statusColor = job.scheduleEnabled ? 'var(--success)' : 'var(--gray-400)';
                const statusText = job.scheduleEnabled ? 'Enabled' : 'Disabled';
                const statusIcon = job.scheduleEnabled ? '‚úì' : '‚úï';
                
                // Get environment
                const jobEnv = getJobEnvironment(job);
                let environmentBadge = '';
                if (jobEnv === 'Canary') {
                    environmentBadge = '<span class="badge badge-warning" style="background: #fef3c7; color: #92400e; font-weight: 600; font-size: 0.75rem;">üü° Canary</span>';
                } else if (jobEnv === 'Non-Canary') {
                    environmentBadge = '<span class="badge badge-info" style="background: #dbeafe; color: #1e40af; font-weight: 600; font-size: 0.75rem;">üîµ Non-Canary</span>';
                } else {
                    environmentBadge = '<span class="badge badge-secondary" style="font-size: 0.75rem;">Unknown</span>';
                }
                
                // Parse all scheduled hours for this job
                const hourString = job.hour || '0';
                const hours = hourString.split(',').map(h => parseInt(h.trim()));
                const allTimes = hours.map(h => formatTime(h.toString(), job.minute, job.seconds)).join(', ');
                const timeLabel = hours.length > 1 ? `${hours.length} times: ${allTimes}` : allTimes;
                
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: white; border-radius: 0.375rem; border-left: 3px solid ${statusColor};">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; font-size: 0.9rem; color: var(--gray-900);">${job.analyticName}</div>
                            <div style="font-size: 0.75rem; color: var(--gray-600); margin-top: 0.25rem;">
                                ‚è∞ ${timeLabel} ‚Ä¢ ${job.frequency}${job.dayInfo ? ' ‚Ä¢ ' + job.dayInfo : ''}
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                            ${environmentBadge}
                            <span class="badge ${job.scheduleEnabled ? 'badge-success' : 'badge-danger'}">${statusIcon} ${statusText}</span>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            listElem.innerHTML = html;
            detailsSection.style.display = 'block';
            
            // Scroll to details section
            detailsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        function hideJobsAtHour() {
            document.getElementById('jobsAtHourDetails').style.display = 'none';
        }
        
        function copyCurlCommandDirect(evt, jobName) {
            const job = JOBS_DATA.find(j => j.name === jobName);
            if (!job) {
                console.error('Job not found:', jobName);
                alert('‚ùå Job not found');
                return;
            }
            
            if (!job.curlCommand) {
                alert('‚ùå No curl command available for this job');
                return;
            }
            
            navigator.clipboard.writeText(job.curlCommand).then(() => {
                // Show a temporary success message
                const btn = evt.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ';
                btn.style.background = 'var(--success)';
                btn.style.color = 'white';
                btn.style.borderColor = 'var(--success)';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                    btn.style.color = '';
                    btn.style.borderColor = '';
                }, 1500);
            }).catch((err) => {
                console.error('Copy failed:', err);
                alert('‚ùå Failed to copy command. Please try again.');
            });
        }
        
        function showCurlModal(jobName) {
            const job = JOBS_DATA.find(j => j.name === jobName);
            if (!job) {
                console.error('Job not found:', jobName);
                return;
            }
            
            // Extract host and path from curl command
            const curlCommand = job.curlCommand || '';
            let host = 'N/A';
            let path = 'N/A';
            
            // Parse URL from curl command (format: curl -X POST 'host/path' or curl -X POST host/path)
            const urlMatch = curlCommand.match(/curl\s+-X\s+POST\s+'?([^'\s]+)'?/);
            if (urlMatch && urlMatch[1]) {
                const url = urlMatch[1];
                // Check if it's a full URL or just host/path
                if (url.startsWith('http://') || url.startsWith('https://')) {
                    try {
                        const urlObj = new URL(url);
                        host = urlObj.hostname;
                        path = urlObj.pathname + urlObj.search;
                    } catch (e) {
                        // If URL parsing fails, try simple split
                        const parts = url.split('/');
                        host = parts[2] || parts[0];
                        path = '/' + parts.slice(3).join('/');
                    }
                } else {
                    // No protocol, just host/path
                    const firstSlash = url.indexOf('/');
                    if (firstSlash > -1) {
                        host = url.substring(0, firstSlash);
                        path = url.substring(firstSlash);
                    } else {
                        host = url;
                        path = '/';
                    }
                }
            }
            
            // Update modal content
            document.getElementById('modalJobName').textContent = job.analyticName;
            document.getElementById('modalHost').textContent = host;
            document.getElementById('modalPath').textContent = path;
            
            // Auto-detect environment based on host in curlCommand
            const isCanaryHost = curlCommand.includes('seller-insights-next.gdn-sg.cld');
            
            if (isCanaryHost) {
                document.getElementById('toggleCanary').classList.add('active');
                document.getElementById('toggleNonCanary').classList.remove('active');
            } else {
                document.getElementById('toggleNonCanary').classList.add('active');
                document.getElementById('toggleCanary').classList.remove('active');
            }
            
            // Reset forceExecute checkbox
            document.getElementById('forceExecuteCheckbox').checked = false;
            
            // Display the curl command with replaced host, requestId, and forceExecute
            let displayCommand = replaceCurlHost(job.curlCommand, isCanaryHost, job.analyticName, false);
            
            // Add Cookie header for canary mode (after the URL)
            if (isCanaryHost) {
                displayCommand = displayCommand.replace(
                    /('https:\/\/[^']+')(\s*\|)?/,
                    `$1 -H "Cookie: ${CANARY_COOKIE}"$2`
                );
            }
            
            document.getElementById('modalCurlCommand').textContent = displayCommand;
            document.getElementById('curlModal').style.display = 'block';
            window.currentModalJob = job;
        }
        
        function updateCurlCommand() {
            if (!window.currentModalJob) return;
            
            const job = window.currentModalJob;
            const isCanary = document.getElementById('toggleCanary').classList.contains('active');
            const forceExecute = document.getElementById('forceExecuteCheckbox').checked;
            
            // Get curl command with all parameters
            let curlCommand = replaceCurlHost(job.curlCommand, isCanary, job.analyticName, forceExecute);
            
            // Add Cookie header for canary mode (after the URL)
            if (isCanary) {
                // Find the URL part and add cookie after it
                curlCommand = curlCommand.replace(
                    /('https:\/\/[^']+')(\s*\|)?/,
                    `$1 -H "Cookie: ${CANARY_COOKIE}"$2`
                );
            }
            
            document.getElementById('modalCurlCommand').textContent = curlCommand;
        }
        
        function replaceCurlHost(curlCommand, isCanary, analyticName, forceExecute = false) {
            if (!curlCommand) return '';
            
            // Replace both internal hosts with public-facing URL
            let modifiedCommand = curlCommand
                .replace(/seller-insights-next\.gdn-sg\.cld/g, 'seller.blibli.com/backend')
                .replace(/seller-insights\.gdn-sg\.cld/g, 'seller.blibli.com/backend');
            
            // Add https:// prefix if not present - handle both quoted and unquoted URLs
            // Pattern 1: curl -X POST 'seller.blibli.com/...
            modifiedCommand = modifiedCommand.replace(
                /curl -X POST '(seller\.blibli\.com)/,
                "curl -X POST 'https://$1"
            );
            
            // Pattern 2: curl -X POST seller.blibli.com/...
            modifiedCommand = modifiedCommand.replace(
                /curl -X POST (seller\.blibli\.com[^\s']+)/,
                "curl -X POST 'https://$1'"
            );
            
            // Add requestId and forceExecute parameters
            if (analyticName) {
                const timestamp = Date.now();
                const requestId = `${analyticName}-${timestamp}`;
                
                // Extract the URL from the command (handle both quoted and unquoted)
                // Match: curl -X POST 'url' or curl -X POST url
                const quotedMatch = modifiedCommand.match(/curl -X POST '([^']+)'/);
                const unquotedMatch = modifiedCommand.match(/curl -X POST ([^\s|]+)/);
                
                if (quotedMatch && quotedMatch[1]) {
                    let url = quotedMatch[1];
                    
                    // Check if URL already has query parameters
                    if (url.includes('?')) {
                        url = url + `&requestId=${requestId}&forceExecute=${forceExecute}`;
                    } else {
                        url = url + `?requestId=${requestId}&forceExecute=${forceExecute}`;
                    }
                    
                    // Replace the URL in the command
                    modifiedCommand = modifiedCommand.replace(/curl -X POST '[^']+'/, `curl -X POST '${url}'`);
                } else if (unquotedMatch && unquotedMatch[1]) {
                    let url = unquotedMatch[1];
                    
                    // Check if URL already has query parameters
                    if (url.includes('?')) {
                        url = url + `&requestId=${requestId}&forceExecute=${forceExecute}`;
                    } else {
                        url = url + `?requestId=${requestId}&forceExecute=${forceExecute}`;
                    }
                    
                    // Replace the URL in the command - maintain quote format
                    modifiedCommand = modifiedCommand.replace(/curl -X POST [^\s|]+/, `curl -X POST '${url}'`);
                }
            }
            
            return modifiedCommand;
        }
        
        function toggleCanaryMode(isCanary) {
            if (!window.currentModalJob) return;
            
            // Update toggle button states
            if (isCanary) {
                document.getElementById('toggleCanary').classList.add('active');
                document.getElementById('toggleNonCanary').classList.remove('active');
            } else {
                document.getElementById('toggleNonCanary').classList.add('active');
                document.getElementById('toggleCanary').classList.remove('active');
            }
            
            // Update the curl command with new settings
            updateCurlCommand();
        }
        
        function copyCurlCommand() {
            const command = document.getElementById('modalCurlCommand').textContent;
            navigator.clipboard.writeText(command).then(() => {
                alert('‚úÖ Command copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy command');
            });
        }
        
        function closeModal() {
            document.getElementById('curlModal').style.display = 'none';
            // Hide execution results when closing modal
            document.getElementById('curlExecutionResults').style.display = 'none';
        }
        
        function showBqDetailsModal(jobName) {
            const job = JOBS_DATA.find(j => j.name === jobName);
            if (!job) {
                console.error('Job not found:', jobName);
                return;
            }
            
            const modal = document.getElementById('bqDetailsModal');
            const bqDetails = job.bqDetails;
            
            // Set job name in header
            document.getElementById('bqModalJobNameHeader').textContent = job.analyticName;
            
            if (!bqDetails || !bqDetails.source) {
                // No BQ details available
                document.getElementById('bqModalSource').textContent = 'No BQ details available';
                document.getElementById('bqModalProjectCount').textContent = '(0 projects)';
                document.getElementById('bqModalProjects').innerHTML = 
                    '<div style="color: var(--gray-500); font-style: italic; text-align: center; padding: 0.75rem;">No projects found</div>';
                document.getElementById('bqModalTableCount').textContent = '(0 tables)';
                document.getElementById('bqModalDependantTables').innerHTML = 
                    '<div style="color: var(--gray-500); font-style: italic; text-align: center; padding: 0.75rem;">No dependant tables found</div>';
            } else {
                // Set source
                document.getElementById('bqModalSource').textContent = bqDetails.source;
                
                // Extract unique BQ projects from source and dependantTables
                const projects = new Set();
                
                // Extract project from source (first part before first dot)
                if (bqDetails.source) {
                    const sourceProject = bqDetails.source.split('.')[0];
                    if (sourceProject) {
                        projects.add(sourceProject);
                    }
                }
                
                // Extract projects from dependantTables
                if (bqDetails.dependantTables && Array.isArray(bqDetails.dependantTables)) {
                    bqDetails.dependantTables.forEach(table => {
                        if (table && typeof table === 'string') {
                            const tableProject = table.split('.')[0];
                            if (tableProject) {
                                projects.add(tableProject);
                            }
                        }
                    });
                }
                
                // Sort projects alphabetically
                const sortedProjects = Array.from(projects).sort();
                
                // Set project count
                const projectCount = sortedProjects.length;
                document.getElementById('bqModalProjectCount').textContent = `(${projectCount} project${projectCount !== 1 ? 's' : ''})`;
                
                // Populate projects
                const projectsContainer = document.getElementById('bqModalProjects');
                if (sortedProjects.length > 0) {
                    projectsContainer.innerHTML = sortedProjects.map((project, index) => `
                        <div style="padding: 0.5rem 0.625rem; background: white; border-radius: 0.25rem; margin-bottom: 0.375rem; border-left: 2px solid var(--primary); display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-size: 0.75rem; font-weight: 600; color: var(--gray-600); min-width: 1.5rem;">${index + 1}.</span>
                            <code style="font-size: 0.8125rem; color: var(--gray-900); font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; word-break: break-all; flex: 1;">${project}</code>
                        </div>
                    `).join('');
                } else {
                    projectsContainer.innerHTML = '<div style="color: var(--gray-500); font-style: italic; text-align: center; padding: 0.75rem;">No projects found</div>';
                }
                
                // Set table count
                const tableCount = bqDetails.dependantTables ? bqDetails.dependantTables.length : 0;
                document.getElementById('bqModalTableCount').textContent = `(${tableCount} table${tableCount !== 1 ? 's' : ''})`;
                
                // Populate dependant tables
                const tablesContainer = document.getElementById('bqModalDependantTables');
                if (bqDetails.dependantTables && bqDetails.dependantTables.length > 0) {
                    tablesContainer.innerHTML = bqDetails.dependantTables.map((table, index) => `
                        <div style="padding: 0.5rem 0.625rem; background: white; border-radius: 0.25rem; margin-bottom: 0.375rem; border-left: 2px solid var(--primary); display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-size: 0.75rem; font-weight: 600; color: var(--gray-600); min-width: 1.5rem;">${index + 1}.</span>
                            <code style="font-size: 0.8125rem; color: var(--gray-900); font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; word-break: break-all; flex: 1;">${table}</code>
                        </div>
                    `).join('');
                } else {
                    tablesContainer.innerHTML = '<div style="color: var(--gray-500); font-style: italic; text-align: center; padding: 0.75rem;">No dependant tables found</div>';
                }
            }
            
            // Show modal
            modal.style.display = 'block';
        }
        
        function closeBqDetailsModal() {
            document.getElementById('bqDetailsModal').style.display = 'none';
        }
        
        function closeSchedulerRunsModal() {
            document.getElementById('schedulerRunsModal').style.display = 'none';
        }
        
        function showSchedulerRunsModal(schedulerName, hour) {
            // Filter patternData to get runs for this scheduler at this hour
            const runs = patternData.filter(p => {
                if (p.analyticName !== schedulerName) return false;
                if (!p.executionStartDate) return false;
                const runHour = new Date(parseInt(p.executionStartDate)).getHours();
                return runHour === hour;
            });
            
            // Sort by execution start date (most recent first)
            runs.sort((a, b) => {
                const dateA = parseInt(a.executionStartDate || 0);
                const dateB = parseInt(b.executionStartDate || 0);
                return dateB - dateA;
            });
            
            // Update modal title
            const matchedJob = matchJobToScheduler(schedulerName);
            let scheduledTime = '';
            let attemptNumber = 1;
            
            if (matchedJob) {
                const hourString = matchedJob.hour || '0';
                const minute = matchedJob.minute || '0';
                const seconds = matchedJob.seconds || '0';
                
                // Get all scheduled hours and sort them chronologically
                const scheduledHours = hourString.split(',').map(h => parseInt(h.trim())).filter(h => !isNaN(h)).sort((a, b) => a - b);
                
                // Find the position of the current hour in the sorted list
                const currentHourIndex = scheduledHours.indexOf(hour);
                if (currentHourIndex !== -1) {
                    // Attempt number is the position in the sorted list (1-based)
                    attemptNumber = currentHourIndex + 1;
                    scheduledTime = ` (Scheduled: ${formatTime(hour.toString(), minute, seconds)})`;
                } else if (scheduledHours.length > 0) {
                    // Current hour not found in scheduled hours, but we have scheduled hours
                    scheduledTime = ` (Scheduled: ${formatTime(scheduledHours[0].toString(), minute, seconds)})`;
                }
            }
            
            document.getElementById('schedulerRunsModalTitle').textContent = 
                `üî• ${schedulerName} at ${hour.toString().padStart(2, '0')}:00${scheduledTime} - Attempt ${attemptNumber}`;
            
            // Build content
            let html = '';
            
            if (runs.length === 0) {
                html = '<div class="no-results" style="font-size: 1rem; padding: 2rem;">No runs found for this scheduler at this hour.</div>';
            } else {
                html = `<div style="overflow-x: auto; overflow-y: auto; max-height: calc(100vh - 300px); border-radius: 0.5rem; border: 1px solid var(--gray-200); box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9375rem;">
                    <thead style="position: sticky; top: 0; z-index: 10;">
                        <tr style="background: linear-gradient(135deg, var(--gray-50) 0%, var(--gray-100) 100%); border-bottom: 2px solid var(--gray-300);">
                            <th style="padding: 0.875rem 1rem; text-align: left; font-weight: 700; color: var(--gray-800); font-size: 0.875rem; letter-spacing: 0.3px;">Date</th>
                            <th style="padding: 0.875rem 1rem; text-align: left; font-weight: 700; color: var(--gray-800); font-size: 0.875rem; letter-spacing: 0.3px;">Start</th>
                            <th style="padding: 0.875rem 1rem; text-align: left; font-weight: 700; color: var(--gray-800); font-size: 0.875rem; letter-spacing: 0.3px;">End</th>
                            <th style="padding: 0.875rem 1rem; text-align: left; font-weight: 700; color: var(--gray-800); font-size: 0.875rem; letter-spacing: 0.3px;">Duration</th>
                            <th style="padding: 0.875rem 1rem; text-align: right; font-weight: 700; color: var(--gray-800); font-size: 0.875rem; letter-spacing: 0.3px;">BQ Data</th>
                            <th style="padding: 0.875rem 1rem; text-align: right; font-weight: 700; color: var(--gray-800); font-size: 0.875rem; letter-spacing: 0.3px;">Saved</th>
                        </tr>
                    </thead>
                    <tbody>`;
                
                runs.forEach((run, index) => {
                    const isSuccess = run.executionSuccess === true;
                    const isFailed = run.executionSuccess === false;
                    const isInProgress = run.executionStartDate && !run.executionFinishDate;
                    
                    let statusText, statusClass, statusBgColor;
                    if (isInProgress) {
                        statusText = 'In Progress';
                        statusClass = 'status-in-progress';
                        statusBgColor = '#dbeafe';
                    } else if (isSuccess) {
                        statusText = 'Success';
                        statusClass = 'status-success';
                        statusBgColor = '#d1fae5';
                    } else {
                        statusText = 'Failed';
                        statusClass = 'status-fail';
                        statusBgColor = '#fee2e2';
                    }
                    
                    const startTime = run.executionStartDate ? formatTimeOnly(run.executionStartDate) : '-';
                    const endTime = run.executionFinishDate ? formatTimeOnly(run.executionFinishDate) : '-';
                    const duration = run.executionStartDate && run.executionFinishDate 
                        ? calculateDuration(run.executionStartDate, run.executionFinishDate) 
                        : null;
                    const durationDisplay = duration ? duration.formatted : '-';
                    
                    const date = run.analyticDate ? formatDate(run.analyticDate) : '-';
                    const attemptStatus = run.attemptStatus || '-';
                    const bqData = run.bqTotalData !== undefined ? run.bqTotalData.toLocaleString() : '-';
                    const savedData = run.analyticTotalData !== undefined ? run.analyticTotalData.toLocaleString() : '-';
                    
                    const borderColor = isSuccess ? '#10b981' : isFailed ? '#ef4444' : '#3b82f6';
                    
                    html += `
                        <tr style="border-bottom: 1px solid var(--gray-200); border-left: 4px solid ${borderColor};">
                            <td style="padding: 0.875rem 1rem; color: var(--gray-900); white-space: nowrap; font-size: 0.9375rem; font-weight: 500;">${date}</td>
                            <td style="padding: 0.875rem 1rem; color: var(--gray-900); font-family: monospace; font-size: 0.9375rem; white-space: nowrap; font-weight: 500;">${startTime}</td>
                            <td style="padding: 0.875rem 1rem; color: var(--gray-900); font-family: monospace; font-size: 0.9375rem; white-space: nowrap; font-weight: 500;">${endTime}</td>
                            <td style="padding: 0.875rem 1rem; color: var(--gray-900); white-space: nowrap; font-size: 0.9375rem; font-weight: 500;">${durationDisplay}</td>
                            <td style="padding: 0.875rem 1rem; text-align: right; color: var(--gray-900); font-size: 0.9375rem; font-weight: 500;">${bqData}</td>
                            <td style="padding: 0.875rem 1rem; text-align: right; color: var(--gray-900); font-size: 0.9375rem; font-weight: 500;">${savedData}</td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table></div>';
            }
            
            document.getElementById('schedulerRunsModalContent').innerHTML = html;
            document.getElementById('schedulerRunsModal').style.display = 'block';
        }
        
        async function executeCurlCommand() {
            const command = document.getElementById('modalCurlCommand').textContent;
            const executeBtn = document.getElementById('executeCurlBtn');
            const resultsDiv = document.getElementById('curlExecutionResults');
            const outputDiv = document.getElementById('curlExecutionOutput');
            
            if (!command || !command.trim()) {
                alert('No command to execute');
                return;
            }
            
            // Disable button and show loading
            if (executeBtn) {
                executeBtn.disabled = true;
                executeBtn.textContent = '‚è≥ Executing...';
            }
            
            if (outputDiv) {
                outputDiv.textContent = 'Executing curl command...';
            }
            
            if (resultsDiv) {
                resultsDiv.style.display = 'block';
            }
            
            try {
                const response = await fetch('/api/execute-curl', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ curl_command: command })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    // Display successful result
                    let output = '';
                    if (result.stdout) {
                        output += result.stdout;
                    }
                    if (result.stderr) {
                        output += '\n\n--- STDERR ---\n' + result.stderr;
                    }
                    if (result.exit_code !== undefined) {
                        output += `\n\n--- Exit Code: ${result.exit_code} ---`;
                    }
                    
                    outputDiv.textContent = output || 'Command executed successfully (no output)';
                    outputDiv.style.color = result.exit_code === 0 ? 'var(--gray-900)' : '#dc2626';
                } else {
                    outputDiv.textContent = `Error: ${result.error || 'Failed to execute command'}`;
                    outputDiv.style.color = '#dc2626';
                }
            } catch (error) {
                outputDiv.textContent = `Error: ${error.message}`;
                outputDiv.style.color = '#dc2626';
            } finally {
                // Re-enable button
                if (executeBtn) {
                    executeBtn.disabled = false;
                    executeBtn.textContent = '‚ö° Execute';
                }
            }
        }
        
        // SSO Token Management Functions (using localStorage)
        function getSsoToken() {
            return localStorage.getItem('sso_token') || null;
        }
        
        function saveSsoToken(token) {
            localStorage.setItem('sso_token', token);
        }
        
        function clearSsoToken() {
            localStorage.removeItem('sso_token');
        }
        
        // SSO Token Modal Functions
        function showSsoTokenModal() {
            const modal = document.getElementById('ssoTokenModal');
            if (modal) {
                modal.style.display = 'block';
                const input = document.getElementById('ssoTokenInput');
                if (input) {
                    // Pre-fill with existing token if available
                    const existingToken = getSsoToken();
                    if (existingToken) {
                        input.value = existingToken;
                    } else {
                        input.value = '';
                    }
                    setTimeout(() => input.focus(), 100);
                }
            }
        }
        
        function closeSsoTokenModal() {
            const modal = document.getElementById('ssoTokenModal');
            if (modal) {
                modal.style.display = 'none';
                const input = document.getElementById('ssoTokenInput');
                if (input) {
                    input.value = '';
                }
            }
        }
        
        async function updateSsoToken() {
            const input = document.getElementById('ssoTokenInput');
            const token = input?.value?.trim();
            
            if (!token) {
                showToast('Error', 'Please enter a valid SSO token', 'error', 4000);
                return;
            }
            
            // Save token to localStorage
            saveSsoToken(token);
            showToast('Success', 'SSO token saved successfully', 'success', 3000);
            closeSsoTokenModal();
            
            // Automatically retry refresh
            setTimeout(() => {
                refreshData();
            }, 500);
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const ssoModal = document.getElementById('ssoTokenModal');
            if (event.target === ssoModal) {
                closeSsoTokenModal();
            }
            const salesFunnelModal = document.getElementById('salesFunnelValidationModal');
            if (event.target === salesFunnelModal) {
                closeSalesFunnelValidationModal();
            }
        }
        
        // Reports Functions
        let reportsCharts = {};
        
        function displayReportsDateRange() {
            // Extract all dates from FILTERED_REPORTS_DATA
            const dates = FILTERED_REPORTS_DATA
                .map(s => parseInt(s.analyticDate))
                .filter(d => !isNaN(d) && d > 0);
            
            if (dates.length === 0) {
                return;
            }
            
            // Find min and max dates
            const minDate = Math.min(...dates);
            const maxDate = Math.max(...dates);
            
            // Format dates
            const startDate = new Date(minDate).toLocaleDateString('en-US', {
                month: 'short', day: 'numeric', year: 'numeric'
            });
            const endDate = new Date(maxDate).toLocaleDateString('en-US', {
                month: 'short', day: 'numeric', year: 'numeric'
            });
            
            // Calculate number of days
            const daysDiff = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24)) + 1;
            
            const dateRangeText = ` (${startDate} - ${endDate})`;
            
            // Update page titles to include date range
            pageTitles['reports-overview'] = `Reports Overview${dateRangeText}`;
            pageTitles['reports-patterns'] = `Pattern Analysis${dateRangeText}`;
            pageTitles['reports-data'] = `All Scheduler Data${dateRangeText}`;
            
            // Update current page title if on a reports page
            const currentPage = document.querySelector('.page-section.active')?.id?.replace('-section', '');
            const pageTitleEl = document.getElementById('pageTitle');
            if (currentPage && pageTitles[currentPage] && pageTitleEl) {
                pageTitleEl.textContent = pageTitles[currentPage];
            }
        }
        
        function updateInsights() {
            const insightsGrid = document.getElementById('insightsGrid');
            if (!insightsGrid) return; // Element doesn't exist, skip update
            
            const totalData = FILTERED_REPORTS_DATA.reduce((sum, s) => sum + parseInt(s.bqTotalData || 0), 0);
            const uniqueTypes = new Set(FILTERED_REPORTS_DATA.map(s => s.analyticName)).size;
            const durations = FILTERED_REPORTS_DATA.map(s => calculateDuration(s.executionStartDate, s.executionFinishDate)).filter(d => d);
            const avgDuration = durations.length ? durations.reduce((sum, d) => sum + d.totalSeconds, 0) / durations.length : 0;
            
            insightsGrid.innerHTML = `
                <div class="insight-card">
                    <div class="insight-label">Total Records</div>
                    <div class="insight-value">${totalData.toLocaleString()}</div>
                </div>
                <div class="insight-card">
                    <div class="insight-label">Unique Types</div>
                    <div class="insight-value">${uniqueTypes}</div>
                </div>
                <div class="insight-card">
                    <div class="insight-label">Avg Duration</div>
                    <div class="insight-value">${Math.floor(avgDuration / 60)}m ${Math.floor(avgDuration % 60)}s</div>
                </div>
            `;
        }
        
        function updatePerformance() {
            const withDuration = FILTERED_REPORTS_DATA.map(s => ({
                name: s.analyticName,
                duration: calculateDuration(s.executionStartDate, s.executionFinishDate),
                bqData: parseInt(s.bqTotalData || 0)
            })).filter(s => s.duration);
            
            const slowest = [...withDuration].sort((a, b) => b.duration.totalSeconds - a.duration.totalSeconds).slice(0, 5);
            const fastest = [...withDuration].sort((a, b) => a.duration.totalSeconds - b.duration.totalSeconds).slice(0, 5);
            const highest = [...FILTERED_REPORTS_DATA].filter(s => s.bqTotalData).sort((a, b) => parseInt(b.bqTotalData) - parseInt(a.bqTotalData)).slice(0, 5);
            const failed = FILTERED_REPORTS_DATA.filter(s => getStatus(s) !== 'success');
            
            let html = '<div class="performance-card"><h3>üêå Slowest Runs</h3>';
            slowest.forEach(s => html += `<div class="perf-item"><span class="perf-item-name">${s.name}</span><span class="perf-item-value">${formatDuration(s.duration)}</span></div>`);
            html += '</div>';
            
            html += '<div class="performance-card"><h3>‚ö° Fastest Runs</h3>';
            fastest.forEach(s => html += `<div class="perf-item"><span class="perf-item-name">${s.name}</span><span class="perf-item-value">${formatDuration(s.duration)}</span></div>`);
            html += '</div>';
            
            html += '<div class="performance-card"><h3>üìä Highest Volume</h3>';
            highest.forEach(s => html += `<div class="perf-item"><span class="perf-item-name">${s.analyticName}</span><span class="perf-item-value">${parseInt(s.bqTotalData).toLocaleString()}</span></div>`);
            html += '</div>';
            
            if (failed.length > 0) {
                html += '<div class="performance-card"><h3>‚ö†Ô∏è Issues</h3>';
                failed.slice(0, 5).forEach(s => html += `<div class="perf-item"><span class="perf-item-name">${s.analyticName}</span><span class="perf-item-value" style="color:var(--danger)">${getStatus(s).toUpperCase()}</span></div>`);
                html += '</div>';
            }
            
            const performanceGrid = document.getElementById('performanceGrid');
            if (performanceGrid) {
                performanceGrid.innerHTML = html;
            }
        }
        
        function renderDailyBreakdownChart() {
            console.log('üîç Rendering Daily Breakdown Chart...');
            console.log('  FILTERED_REPORTS_DATA length:', FILTERED_REPORTS_DATA.length);
            
            const byDate = {};
            FILTERED_REPORTS_DATA.forEach(s => {
                const date = s.analyticDate;
                if (!byDate[date]) byDate[date] = { total: 0, success: 0, failed: 0 };
                byDate[date].total++;
                if (getStatus(s) === 'success') byDate[date].success++;
                else byDate[date].failed++;
            });
            
            const sorted = Object.keys(byDate).sort((a, b) => parseInt(a) - parseInt(b));
            console.log('  Dates found:', sorted.length);
            console.log('  Date data:', byDate);
            
            if (sorted.length === 0) {
                const chartContainer = document.getElementById('dailyBreakdownChart');
                if (chartContainer) {
                    chartContainer.innerHTML = '<div style="padding: 3rem; text-align: center; color: var(--gray-500);"><div style="font-size: 3rem; margin-bottom: 1rem;">üìä</div><div style="font-size: 1rem;">No data available for the selected date range</div></div>';
                }
                return;
            }
            
            const maxTotal = Math.max(...sorted.map(date => byDate[date].total));
            console.log('  Max total:', maxTotal);
            
            const chartHeight = 180;
            
            let html = '<div style="background: white; border-radius: 0.5rem; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); width: 100%; box-sizing: border-box;">';
            
            // Chart container with better spacing for labels
            html += `<div style="width: 100%; padding: 0.5rem 0 4rem 0; box-sizing: border-box; overflow: visible;">`;
            html += `<div style="display: flex; gap: 6px; align-items: flex-end; height: ${chartHeight}px; border-bottom: 2px solid #e5e7eb; position: relative; padding-bottom: 0.75rem; width: 100%; box-sizing: border-box; margin-bottom: 0.5rem;">`;
            
            sorted.forEach((date, index) => {
                const data = byDate[date];
                const totalHeight = chartHeight - 50; // More space for labels
                const successHeightPx = Math.max(4, Math.round((data.success / maxTotal) * totalHeight));
                const failedHeightPx = Math.max(4, Math.round((data.failed / maxTotal) * totalHeight));
                const successPct = ((data.success / data.total) * 100).toFixed(0);
                const failedPct = ((data.failed / data.total) * 100).toFixed(0);
                
                // Format date for display
                const dateObj = new Date(parseInt(date));
                const dateStr = dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                
                html += `<div style="flex: 1; min-width: 0; display: flex; flex-direction: column; align-items: center; position: relative; max-width: 100%;" class="daily-breakdown-bar">`;
                
                // Total count badge on top - more visible
                html += `<div style="font-size: 0.75rem; font-weight: 700; color: #1e293b; margin-bottom: 0.5rem; text-align: center; 
                         background: #f1f5f9; padding: 0.25rem 0.5rem; border-radius: 0.375rem; border: 1px solid #cbd5e1; cursor: help; white-space: nowrap;"
                         title="Total Schedulers: ${data.total}\\n\\nBreakdown:\\n- Success: ${data.success}\\n- Failed: ${data.failed}\\n\\nDate: ${dateStr}">
                    ${data.total}
                </div>`;
                
                // Bar container
                html += `<div style="width: 100%; display: flex; flex-direction: column; justify-content: flex-end; 
                         height: ${totalHeight}px; gap: 1px; position: relative;">`;
                
                // Success bar
                if (data.success > 0) {
                    html += `<div class="success-bar" 
                             style="width: 100%; 
                             background: linear-gradient(180deg, #10b981 0%, #059669 100%); 
                             border-radius: ${data.failed > 0 ? '0.375rem 0.375rem 0 0' : '0.375rem'}; 
                             height: ${successHeightPx}px; 
                             position: relative; 
                             cursor: help; 
                             transition: opacity 0.2s ease;
                             box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);"
                             onmouseover="this.style.opacity='0.85'" 
                             onmouseout="this.style.opacity='1'"
                             title="Success: ${data.success} schedulers (${successPct}%)">
                        ${successHeightPx > 20 ? `<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                         color: white; font-size: 0.7rem; font-weight: 700; text-shadow: 0 1px 3px rgba(0,0,0,0.4);">${data.success}</div>` : ''}
                    </div>`;
                }
                
                // Failed bar
                if (data.failed > 0) {
                    html += `<div class="failed-bar"
                             style="width: 100%; 
                             background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%); 
                             ${data.success > 0 ? 'border-radius: 0 0 0.375rem 0.375rem;' : 'border-radius: 0.375rem;'} 
                             height: ${failedHeightPx}px; 
                             position: relative; 
                             cursor: help; 
                             transition: opacity 0.2s ease;
                             box-shadow: 0 2px 4px rgba(239, 68, 68, 0.2);"
                             onmouseover="this.style.opacity='0.85'" 
                             onmouseout="this.style.opacity='1'"
                             title="Failed: ${data.failed} schedulers (${failedPct}%)">
                        ${failedHeightPx > 20 ? `<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                         color: white; font-size: 0.7rem; font-weight: 700; text-shadow: 0 1px 3px rgba(0,0,0,0.4);">${data.failed}</div>` : ''}
                    </div>`;
                }
                
                html += '</div>'; // End bar container
                
                // Date label - larger and more visible
                html += `<div style="position: absolute; top: ${chartHeight + 10}px; left: 50%; transform: translateX(-50%); 
                         font-size: 0.75rem; color: #1e293b; text-align: center; white-space: nowrap; font-weight: 600; 
                         width: 100%; overflow: visible; z-index: 2; background: white; padding: 0.125rem 0.25rem; line-height: 1.2;">
                    ${dateStr}
                </div>`;
                
                // Success and Failed counts below date - always visible with better styling
                html += `<div style="position: absolute; top: ${chartHeight + 28}px; left: 50%; transform: translateX(-50%); 
                         font-size: 0.75rem; text-align: center; white-space: nowrap; z-index: 2; background: white; padding: 0.125rem 0.25rem; width: 100%; line-height: 1.4;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.75rem; flex-wrap: wrap;">
                        <span style="color: #059669; font-weight: 700; font-size: 0.8rem; display: inline-flex; align-items: center; gap: 0.25rem;">
                            <span style="font-size: 0.9rem;">‚úì</span>${data.success}
                        </span>
                        ${data.failed > 0 ? `<span style="color: #dc2626; font-weight: 700; font-size: 0.8rem; display: inline-flex; align-items: center; gap: 0.25rem;">
                            <span style="font-size: 0.9rem;">‚úó</span>${data.failed}
                        </span>` : '<span style="color: #94a3b8; font-size: 0.7rem;">No failures</span>'}
                    </div>
                </div>`;
                
                html += '</div>'; // End bar wrapper
            });
            
            html += '</div></div>';
            
            console.log('  Generated HTML length:', html.length);
            console.log('  Setting innerHTML...');
            const chartContainer = document.getElementById('dailyBreakdownChart');
            if (chartContainer) {
                chartContainer.innerHTML = html;
                console.log('‚úÖ Daily Breakdown Chart rendered');
            }
        }
        
        function populateDateFilter() {
            const dates = [...new Set(FILTERED_REPORTS_DATA.map(s => s.analyticDate))].sort((a, b) => parseInt(b) - parseInt(a));
            const select = document.getElementById('dateFilter');
            dates.forEach(date => {
                const opt = document.createElement('option');
                opt.value = date;
                opt.textContent = formatDateShort(date);
                select.appendChild(opt);
            });
        }
        
        function filterReports() {
            const reportSearchEl = document.getElementById('reportSearch');
            const dateFilterEl = document.getElementById('dateFilter');
            const reportStatusFilterEl = document.getElementById('reportStatusFilter');
            
            // If elements don't exist, return all filtered data
            if (!reportSearchEl || !dateFilterEl || !reportStatusFilterEl) {
                return FILTERED_REPORTS_DATA;
            }
            
            const search = reportSearchEl.value.toLowerCase();
            const date = dateFilterEl.value;
            const status = reportStatusFilterEl.value;
            
            return FILTERED_REPORTS_DATA.filter(s => {
                const matchSearch = !search || s.analyticName.toLowerCase().includes(search);
                const matchDate = !date || s.analyticDate === date;
                const matchStatus = !status || getStatus(s) === status;
                return matchSearch && matchDate && matchStatus;
            });
        }
        
        function sortReports(reports, column, direction) {
            return [...reports].sort((a, b) => {
                let valA, valB;
                switch(column) {
                    case 'date': valA = parseInt(a.analyticDate); valB = parseInt(b.analyticDate); break;
                    case 'name': valA = a.analyticName.toLowerCase(); valB = b.analyticName.toLowerCase(); break;
                    case 'status': valA = getStatus(a); valB = getStatus(b); break;
                    case 'bqData': valA = parseInt(a.bqTotalData || 0); valB = parseInt(b.bqTotalData || 0); break;
                    case 'start': valA = parseInt(a.executionStartDate || 0); valB = parseInt(b.executionStartDate || 0); break;
                    case 'end': valA = parseInt(a.executionFinishDate || 0); valB = parseInt(b.executionFinishDate || 0); break;
                    case 'duration':
                        const dA = calculateDuration(a.executionStartDate, a.executionFinishDate);
                        const dB = calculateDuration(b.executionStartDate, b.executionFinishDate);
                        valA = dA ? dA.totalSeconds : 0;
                        valB = dB ? dB.totalSeconds : 0;
                        break;
                    default: return 0;
                }
                if (valA < valB) return direction === 'asc' ? -1 : 1;
                if (valA > valB) return direction === 'asc' ? 1 : -1;
                return 0;
            });
        }
        
        function renderReportsTable() {
            const tbody = document.getElementById('reportsTableBody');
            if (!tbody) return; // Element doesn't exist, skip
            
            filteredReports = filterReports();
            if (reportSort.column) {
                filteredReports = sortReports(filteredReports, reportSort.column, reportSort.direction);
            }
            
            if (filteredReports.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="no-results">No results found</td></tr>';
                return;
            }
            
            tbody.innerHTML = filteredReports.map(s => {
                const status = getStatus(s);
                const duration = calculateDuration(s.executionStartDate, s.executionFinishDate);
                return `
                    <tr>
                        <td><span class="badge badge-info">${formatDateShort(s.analyticDate)}</span></td>
                        <td><strong>${s.analyticName}</strong></td>
                        <td><span class="badge badge-${status}">${status}</span></td>
                        <td>${s.bqTotalData ? parseInt(s.bqTotalData).toLocaleString() : '-'}</td>
                        <td>${formatDateTime(s.executionStartDate)}</td>
                        <td>${formatDateTime(s.executionFinishDate)}</td>
                        <td>${formatDuration(duration)}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Today's Report Functions
        function toIntSafe(v) {
            const num = parseInt(v, 10);
            return isNaN(num) ? 0 : num;
        }
        
        function renderFailedSchedulers(failedJobs) {
            const failedSection = document.getElementById('todayFailedSection');
            const failedList = document.getElementById('todayFailedList');
            
            if (failedJobs.length === 0) {
                failedSection.style.display = 'none';
                return;
            }
            
            failedSection.style.display = 'block';
            
            // Group failures by analytic name
            const failuresByName = {};
            failedJobs.forEach(job => {
                const name = job.analyticName || 'Unknown';
                if (!failuresByName[name]) {
                    failuresByName[name] = [];
                }
                failuresByName[name].push(job);
            });
            
            let html = '';
            let index = 0;
            
            Object.keys(failuresByName).sort().forEach(analyticName => {
                const failures = failuresByName[analyticName];
                
                // Find matching Rundeck job
                const matchedJob = JOBS_DATA.find(j => j.analyticName === analyticName);
                
                // Get scheduled hours for this job
                let scheduledHours = [];
                let scheduledTimes = [];
                if (matchedJob) {
                    const hourString = matchedJob.hour || '0';
                    scheduledHours = hourString.split(',').map(h => parseInt(h.trim()));
                    scheduledTimes = scheduledHours.map(h => formatTime(h.toString(), matchedJob.minute, matchedJob.seconds));
                }
                
                // Get the hours when failures occurred
                const failedHours = failures.map(f => {
                    if (f.executionStartDate) {
                        return new Date(parseInt(f.executionStartDate)).getHours();
                    }
                    return null;
                }).filter(h => h !== null);
                
                // Check if all scheduled slots failed
                const allSlotsFailed = matchedJob && scheduledHours.length > 0 && 
                    scheduledHours.every(hour => failedHours.includes(hour));
                
                // Display each failure
                failures.forEach((job) => {
                    index++;
                    const executionTime = job.executionStartDate 
                        ? new Date(parseInt(job.executionStartDate)).toLocaleTimeString('en-US', { 
                            hour: '2-digit', 
                            minute: '2-digit', 
                            second: '2-digit',
                            hour12: false 
                        })
                        : 'N/A';
                    
                    const executionHour = job.executionStartDate 
                        ? new Date(parseInt(job.executionStartDate)).getHours()
                        : null;
                    
                    const executionDate = job.executionStartDate 
                        ? new Date(parseInt(job.executionStartDate)).toLocaleDateString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            year: 'numeric'
                        })
                        : 'N/A';
                    
                    // Determine which slot this failure belongs to
                    let slotPosition = -1;
                    let isFirstSlot = false;
                    let isLastSlot = false;
                    let remainingAttempts = 0;
                    let failedAttempts = 0;
                    let retryStatusMessage = '';
                    let severityBadge = '';
                    let borderColor = 'var(--danger)';
                    
                    if (matchedJob && scheduledHours.length > 0 && executionHour !== null) {
                        // Find which slot this failure occurred in
                        slotPosition = scheduledHours.indexOf(executionHour);
                        
                        if (slotPosition !== -1) {
                            isFirstSlot = slotPosition === 0;
                            isLastSlot = slotPosition === scheduledHours.length - 1;
                            failedAttempts = slotPosition + 1;
                            remainingAttempts = scheduledHours.length - failedAttempts;
                            
                            if (isFirstSlot && scheduledHours.length > 1) {
                                // First slot failed - still have retries
                                retryStatusMessage = `<span style="color: var(--warning); font-weight: 600;">‚ö†Ô∏è First attempt failed - ${remainingAttempts} retry slot${remainingAttempts > 1 ? 's' : ''} remaining (${scheduledHours.slice(1).map((h, i) => scheduledTimes[slotPosition + 1 + i]).join(', ')})</span>`;
                                severityBadge = '';
                                borderColor = '#f59e0b'; // Orange for warning
                            } else if (isLastSlot) {
                                // Last slot failed - no more retries
                                retryStatusMessage = `<span style="color: #b91c1c; font-weight: 700;">üö® FINAL ATTEMPT FAILED - No more retry slots for today</span>`;
                                severityBadge = '<span style="background: #b91c1c; color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.7rem; font-weight: 600; margin-left: 0.5rem;">üö® FINAL FAILURE</span>';
                                borderColor = '#b91c1c'; // Dark red for critical
                            } else {
                                // Middle slot failed
                                retryStatusMessage = `<span style="color: var(--warning); font-weight: 600;">‚ö†Ô∏è Retry attempt ${failedAttempts} failed - ${remainingAttempts} attempt${remainingAttempts > 1 ? 's' : ''} remaining (${scheduledHours.slice(slotPosition + 1).map((h, i) => scheduledTimes[slotPosition + 1 + i]).join(', ')})</span>`;
                                severityBadge = '<span style="background: var(--warning); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.7rem; font-weight: 600; margin-left: 0.5rem;">‚ö†Ô∏è RETRY FAILED</span>';
                                borderColor = '#f59e0b'; // Orange
                            }
                        }
                    } else if (allSlotsFailed) {
                        borderColor = '#b91c1c';
                        severityBadge = '<span style="background: #b91c1c; color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.7rem; font-weight: 600; margin-left: 0.5rem;">‚ö†Ô∏è ALL SLOTS FAILED</span>';
                    }
                    
                    html += `
                        <div style="display: flex; align-items: center; padding: 1rem; background: white; border-radius: 0.5rem; border-left: 4px solid ${borderColor}; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; flex-wrap: wrap;">
                                    <span style="background: var(--danger); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">#${index}</span>
                                    <span style="font-weight: 700; font-size: 1rem; color: var(--gray-900);">${job.analyticName || 'Unknown'}</span>
                                    ${severityBadge}
                                </div>
                                <div style="display: flex; gap: 1.5rem; font-size: 0.875rem; color: var(--gray-600); flex-wrap: wrap;">
                                    <div style="display: flex; align-items: center; gap: 0.375rem;">
                                        <span>üïê</span>
                                        <span><strong>Failed at:</strong> ${executionTime}</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 0.375rem;">
                                        <span>üìÖ</span>
                                        <span>${executionDate}</span>
                                    </div>
                                    ${job.analyticTotalData ? `
                                    <div style="display: flex; align-items: center; gap: 0.375rem;">
                                        <span>üìä</span>
                                        <span>${parseInt(job.analyticTotalData).toLocaleString()} rows</span>
                                    </div>
                                    ` : ''}
                                </div>
                                ${matchedJob ? `
                                <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--gray-200);">
                                    <div style="font-size: 0.8rem; color: var(--gray-700); margin-bottom: 0.375rem;">
                                        <strong>Rundeck Schedule:</strong> ${scheduledTimes.join(', ')} ‚Ä¢ ${matchedJob.frequency}${matchedJob.dayInfo ? ' ‚Ä¢ ' + matchedJob.dayInfo : ''}
                                    </div>
                                    <div style="font-size: 0.8rem; color: var(--gray-600);">
                                        <strong>Retry Status:</strong> 
                                        ${retryStatusMessage || (allSlotsFailed 
                                            ? `<span style="color: #b91c1c; font-weight: 600;">Failed at all ${scheduledHours.length} scheduled time slots</span>` 
                                            : `<span style="color: var(--warning);">Failed at ${failedHours.length} of ${scheduledHours.length} scheduled slots</span>`
                                        )}
                                    </div>
                                </div>
                                ` : '<div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--gray-500);"><em>No matching Rundeck job found</em></div>'}
                            </div>
                            <div>
                                <span class="badge badge-danger" style="font-size: 0.875rem; padding: 0.5rem 0.75rem;">‚ùå Failed</span>
                            </div>
                        </div>
                    `;
                });
            });
            
            failedList.innerHTML = html;
        }
        
        // Function to check if a job runs today based on frequency and dayInfo
        function jobRunsToday(job) {
            if (!job.scheduleEnabled) {
                return false;
            }
            
            const today = new Date();
            const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            const dayOfMonth = today.getDate(); // 1-31
            const dayNames = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
            const todayDayName = dayNames[dayOfWeek];
            
            if (job.frequency === 'Daily') {
                // Daily jobs run every day (dayInfo is usually empty)
                return true;
            } else if (job.frequency === 'Weekly') {
                // Weekly jobs: check if today's day is in dayInfo
                if (!job.dayInfo || job.dayInfo.trim() === '') {
                    return false;
                }
                const days = job.dayInfo.split(',').map(d => d.trim().toUpperCase());
                return days.includes(todayDayName);
            } else if (job.frequency === 'Monthly') {
                // Monthly jobs: check if today's day of month is in dayInfo (format: "Day 1,2,3" or "Day 1")
                if (!job.dayInfo || job.dayInfo.trim() === '') {
                    return false;
                }
                // Extract day numbers from "Day 1,2,3" format
                const dayMatch = job.dayInfo.match(/Day\s*([\d,\s]+)/i);
                if (!dayMatch) {
                    return false;
                }
                const dayNumbers = dayMatch[1].split(',').map(d => parseInt(d.trim())).filter(d => !isNaN(d));
                return dayNumbers.includes(dayOfMonth);
            }
            
            return false;
        }
        
        // Helper function to get environment from job
        function getTodayJobEnvironment(job) {
            if (!job || !job.curlCommand) return 'Unknown';
            if (job.curlCommand.includes('seller-insights-next.gdn-sg.cld')) return 'Canary';
            if (job.curlCommand.includes('seller-insights.gdn-sg.cld')) return 'Non-Canary';
            return 'Unknown';
        }
        
        // Function to get jobs that run today and match them with today's data
        function getTodayScheduledJobs() {
            // Filter jobs that run today
            const jobsRunningToday = JOBS_DATA.filter(job => jobRunsToday(job));
            
            // Create a map of analyticName to job data for quick lookup
            const jobsMap = new Map();
            jobsRunningToday.forEach(job => {
                jobsMap.set(job.analyticName, job);
            });
            
            // Create a map of analyticName to today's execution data
            const todayDataMap = new Map();
            TODAY_DATA.forEach(data => {
                const analyticName = data.analyticName;
                if (!todayDataMap.has(analyticName)) {
                    todayDataMap.set(analyticName, []);
                }
                todayDataMap.get(analyticName).push(data);
            });
            
            // Build result: combine scheduled jobs with their execution data
            const result = [];
            jobsRunningToday.forEach(job => {
                const executionData = todayDataMap.get(job.analyticName) || [];
                const environment = getTodayJobEnvironment(job);
                
                if (executionData.length > 0) {
                    // If there's execution data, add each execution as a row
                    executionData.forEach(data => {
                        result.push({
                            ...data,
                            scheduledJob: job, // Keep reference to the scheduled job
                            environment: environment // Add environment info
                        });
                    });
                } else {
                    // If no execution data yet, still show the scheduled job (pending)
                    result.push({
                        analyticName: job.analyticName,
                        executionSuccess: undefined,
                        scheduledJob: job,
                        environment: environment // Add environment info
                    });
                }
            });
            
            return result;
        }
        
        function initTodayReport() {
            // Populate Tab filter dropdown
            const todayTabFilter = document.getElementById('todayTabFilter');
            if (todayTabFilter) {
                const uniqueTabs = [...new Set(JOBS_DATA.map(job => job.tab).filter(tab => tab !== null && tab !== undefined))].sort();
                
                // Clear existing options except "All"
                todayTabFilter.innerHTML = '<option value="All">All</option>';
                
                // Add unique tabs
                uniqueTabs.forEach(tab => {
                    const option = document.createElement('option');
                    option.value = tab;
                    option.textContent = tab;
                    todayTabFilter.appendChild(option);
                });
                
                // Add "None" option if there are jobs without tabs
                if (JOBS_DATA.some(job => !job.tab)) {
                    const noneOption = document.createElement('option');
                    noneOption.value = 'None';
                    noneOption.textContent = 'None';
                    todayTabFilter.appendChild(noneOption);
                }
            }
            
            // Get jobs scheduled for today with their execution data
            const todayScheduledData = getTodayScheduledJobs();
            
            // Categorize jobs based on execution status
            const succeededJobs = todayScheduledData.filter(j => j.executionSuccess === true);
            const failedJobs = todayScheduledData.filter(j => j.executionSuccess === false);
            
            // In Progress: has start time but no finish time
            const inProgressJobs = todayScheduledData.filter(j => 
                j.executionStartDate && !j.executionFinishDate
            );
            
            // Pending: no start time (hasn't started yet)
            const pendingJobs = todayScheduledData.filter(j => 
                !j.executionStartDate && j.executionSuccess === undefined
            );
            
            const totalJobs = todayScheduledData.length;
            
            // Helper function to get environment from job
            const getJobEnv = (job) => {
                return job.environment || getTodayJobEnvironment(job.scheduledJob || matchJobToScheduler(job.analyticName));
            };
            
            // Calculate Canary/Non-Canary counts for each category
            const totalCanary = todayScheduledData.filter(j => getJobEnv(j) === 'Canary').length;
            const totalNonCanary = todayScheduledData.filter(j => getJobEnv(j) === 'Non-Canary').length;
            
            const pendingCanary = pendingJobs.filter(j => getJobEnv(j) === 'Canary').length;
            const pendingNonCanary = pendingJobs.filter(j => getJobEnv(j) === 'Non-Canary').length;
            
            const inProgressCanary = inProgressJobs.filter(j => getJobEnv(j) === 'Canary').length;
            const inProgressNonCanary = inProgressJobs.filter(j => getJobEnv(j) === 'Non-Canary').length;
            
            const succeededCanary = succeededJobs.filter(j => getJobEnv(j) === 'Canary').length;
            const succeededNonCanary = succeededJobs.filter(j => getJobEnv(j) === 'Non-Canary').length;
            
            const failedCanary = failedJobs.filter(j => getJobEnv(j) === 'Canary').length;
            const failedNonCanary = failedJobs.filter(j => getJobEnv(j) === 'Non-Canary').length;
            
            // Update main counts
            document.getElementById('todaySucceeded').textContent = succeededJobs.length;
            document.getElementById('todayFailed').textContent = failedJobs.length;
            document.getElementById('todayTotal').textContent = totalJobs;
            document.getElementById('todayPending').textContent = pendingJobs.length;
            document.getElementById('todayInProgress').textContent = inProgressJobs.length;
            
            // Update Canary/Non-Canary counts
            document.getElementById('todayTotalCanary').textContent = totalCanary;
            document.getElementById('todayTotalNonCanary').textContent = totalNonCanary;
            document.getElementById('todayPendingCanary').textContent = pendingCanary;
            document.getElementById('todayPendingNonCanary').textContent = pendingNonCanary;
            document.getElementById('todayInProgressCanary').textContent = inProgressCanary;
            document.getElementById('todayInProgressNonCanary').textContent = inProgressNonCanary;
            document.getElementById('todaySucceededCanary').textContent = succeededCanary;
            document.getElementById('todaySucceededNonCanary').textContent = succeededNonCanary;
            document.getElementById('todayFailedCanary').textContent = failedCanary;
            document.getElementById('todayFailedNonCanary').textContent = failedNonCanary;
            
            // Set initial card active state based on current filter
            const initialStatusFilter = document.getElementById('todayStatusFilter');
            if (initialStatusFilter) {
                updateCardActiveState(initialStatusFilter.value);
            }
            
            // Render failed schedulers section (only jobs with execution data that failed)
            renderFailedSchedulers(failedJobs);
            
            // Today's table - show scheduled jobs with their execution data
            renderTodayTable(todayScheduledData);
            
            // Store todayScheduledData for search/filter
            window.todayScheduledData = todayScheduledData;
            window.todayFilteredData = todayScheduledData; // Store current filtered data for sorting
            
            // Function to clear today's search (make it globally accessible)
            window.clearTodaySearch = function() {
                const searchInput = document.getElementById('todaySearchInput');
                if (searchInput) {
                    searchInput.value = '';
                    updateTodaySearchClearButton();
                    if (typeof applyTodayFilters === 'function') {
                        applyTodayFilters();
                    }
                }
            };
            
            function updateTodaySearchClearButton() {
                const input = document.getElementById('todaySearchInput');
                if (input) {
                    const clearBtn = input.parentElement.querySelector('.search-clear-btn');
                    if (clearBtn) {
                        if (input.value.trim() !== '') {
                            clearBtn.classList.add('visible');
                        } else {
                            clearBtn.classList.remove('visible');
                        }
                    }
                }
            }
            
            // Function to apply all filters
            function applyTodayFilters() {
                const searchVal = document.getElementById('todaySearchInput').value.toLowerCase().trim();
                const statusFilter = document.getElementById('todayStatusFilter').value;
                const frequencyFilter = document.getElementById('todayFrequencyFilter').value;
                const environmentFilter = document.getElementById('todayEnvironmentFilter').value;
                const tabFilter = document.getElementById('todayTabFilter') ? document.getElementById('todayTabFilter').value : 'All';
                
                let filtered = todayScheduledData.filter(job => {
                    // Search filter
                    const matchesSearch = (job.analyticName || '').toLowerCase().includes(searchVal);
                    if (!matchesSearch) return false;
                    
                    // Status filter
                    if (statusFilter !== 'All') {
                        const isPending = !job.executionStartDate && job.executionSuccess === undefined;
                        const isInProgress = job.executionStartDate && !job.executionFinishDate;
                        const isSuccess = job.executionSuccess === true;
                        const isFailed = job.executionSuccess === false;
                        
                        if (statusFilter === 'Pending' && !isPending) return false;
                        if (statusFilter === 'In Progress' && !isInProgress) return false;
                        if (statusFilter === 'Success' && !isSuccess) return false;
                        if (statusFilter === 'Failed' && !isFailed) return false;
                    }
                    
                    // Frequency filter
                    if (frequencyFilter !== 'All') {
                        const scheduledJob = job.scheduledJob || matchJobToScheduler(job.analyticName);
                        if (!scheduledJob || scheduledJob.frequency !== frequencyFilter) {
                            return false;
                        }
                    }
                    
                    // Environment filter
                    if (environmentFilter !== 'All') {
                        const jobEnvironment = job.environment || getTodayJobEnvironment(job.scheduledJob || matchJobToScheduler(job.analyticName));
                        if (jobEnvironment !== environmentFilter) {
                            return false;
                        }
                    }
                    
                    // Tab filter
                    if (tabFilter !== 'All') {
                        const scheduledJob = job.scheduledJob || matchJobToScheduler(job.analyticName);
                        const jobTab = scheduledJob ? scheduledJob.tab : null;
                        if (tabFilter === 'None' && jobTab) return false;
                        if (tabFilter !== 'None' && jobTab !== tabFilter) return false;
                    }
                    
                    return true;
                });
                
                window.todayFilteredData = filtered; // Update filtered data
                renderTodayTable(filtered);
            }
            
            // Set up filter handlers
            const searchInput = document.getElementById('todaySearchInput');
            const statusFilter = document.getElementById('todayStatusFilter');
            const frequencyFilter = document.getElementById('todayFrequencyFilter');
            const environmentFilter = document.getElementById('todayEnvironmentFilter');
            const tabFilter = document.getElementById('todayTabFilter');
            
            searchInput.oninput = function() {
                updateTodaySearchClearButton();
                applyTodayFilters();
            };
            frequencyFilter.onchange = applyTodayFilters;
            environmentFilter.onchange = applyTodayFilters;
            if (tabFilter) {
                tabFilter.onchange = applyTodayFilters;
            }
            
            // Update card active state when status filter changes manually
            statusFilter.onchange = function() {
                updateCardActiveState(statusFilter.value);
                applyTodayFilters();
            };
            
            // Set up sort handlers (replace any existing handlers)
            document.querySelectorAll('#todaySchedulerTable th.sortable').forEach(th => {
                th.onclick = () => {
                    const key = th.getAttribute('data-key');
                    const currentDir = th.classList.contains('sort-asc') ? 'desc' : 'asc';
                    
                    document.querySelectorAll('#todaySchedulerTable th').forEach(h => {
                        h.classList.remove('sort-asc', 'sort-desc');
                    });
                    th.classList.add(`sort-${currentDir}`);
                    
                    // Use current filtered data for sorting
                    const sorted = [...(window.todayFilteredData || window.todayScheduledData || [])].sort((a, b) => {
                        let aVal = a[key];
                        let bVal = b[key];
                        
                        if (key === 'executionSuccess') {
                            aVal = aVal === true ? 1 : 0;
                            bVal = bVal === true ? 1 : 0;
                        }
                        if (key === 'analyticTotalData' || key === 'bqTotalData') {
                            aVal = toIntSafe(aVal);
                            bVal = toIntSafe(bVal);
                        }
                        if (key === 'executionStartDate' || key === 'executionFinishDate') {
                            aVal = parseInt(aVal) || 0;
                            bVal = parseInt(bVal) || 0;
                        }
                        if (key === 'duration') {
                            // Calculate duration in seconds for sorting
                            const aDuration = calculateDuration(a.executionStartDate, a.executionFinishDate);
                            const bDuration = calculateDuration(b.executionStartDate, b.executionFinishDate);
                            aVal = aDuration ? aDuration.totalSeconds : 0;
                            bVal = bDuration ? bDuration.totalSeconds : 0;
                        }
                        if (key === 'analyticName') {
                            aVal = (aVal || '').toLowerCase();
                            bVal = (bVal || '').toLowerCase();
                        }
                        
                        if (aVal < bVal) return currentDir === 'asc' ? -1 : 1;
                        if (aVal > bVal) return currentDir === 'asc' ? 1 : -1;
                        return 0;
                    });
                    renderTodayTable(sorted);
                };
            });
        }
        
        function updateCardActiveState(statusValue) {
            // Remove active class from all cards
            document.querySelectorAll('.stat-card.clickable').forEach(card => {
                card.classList.remove('active');
            });
            
            // Add active class to the corresponding card
            let cardId;
            if (statusValue === 'All') {
                cardId = 'todayCardTotal';
            } else if (statusValue === 'Pending') {
                cardId = 'todayCardPending';
            } else if (statusValue === 'In Progress') {
                cardId = 'todayCardInProgress';
            } else if (statusValue === 'Success') {
                cardId = 'todayCardSuccess';
            } else if (statusValue === 'Failed') {
                cardId = 'todayCardFailed';
            }
            
            if (cardId) {
                const card = document.getElementById(cardId);
                if (card) {
                    card.classList.add('active');
                }
            }
        }
        
        function filterTodayByCard(statusValue) {
            // Update the status filter dropdown
            const statusFilter = document.getElementById('todayStatusFilter');
            if (statusFilter) {
                statusFilter.value = statusValue;
                updateCardActiveState(statusValue);
                
                // Trigger the filter function
                const searchInput = document.getElementById('todaySearchInput');
                const frequencyFilter = document.getElementById('todayFrequencyFilter');
                const environmentFilter = document.getElementById('todayEnvironmentFilter');
                const searchVal = searchInput ? searchInput.value.toLowerCase().trim() : '';
                const freqVal = frequencyFilter ? frequencyFilter.value : 'All';
                const envVal = environmentFilter ? environmentFilter.value : 'All';
                
                let filtered = window.todayScheduledData.filter(job => {
                    // Search filter
                    const matchesSearch = (job.analyticName || '').toLowerCase().includes(searchVal);
                    if (!matchesSearch) return false;
                    
                    // Status filter
                    if (statusValue !== 'All') {
                        const isPending = !job.executionStartDate && job.executionSuccess === undefined;
                        const isInProgress = job.executionStartDate && !job.executionFinishDate;
                        const isSuccess = job.executionSuccess === true;
                        const isFailed = job.executionSuccess === false;
                        
                        if (statusValue === 'Pending' && !isPending) return false;
                        if (statusValue === 'In Progress' && !isInProgress) return false;
                        if (statusValue === 'Success' && !isSuccess) return false;
                        if (statusValue === 'Failed' && !isFailed) return false;
                    }
                    
                    // Frequency filter
                    if (freqVal !== 'All') {
                        const scheduledJob = job.scheduledJob || matchJobToScheduler(job.analyticName);
                        if (!scheduledJob || scheduledJob.frequency !== freqVal) {
                            return false;
                        }
                    }
                    
                    // Environment filter
                    if (envVal !== 'All') {
                        const jobEnvironment = job.environment || getTodayJobEnvironment(job.scheduledJob || matchJobToScheduler(job.analyticName));
                        if (jobEnvironment !== envVal) {
                            return false;
                        }
                    }
                    
                    return true;
                });
                
                window.todayFilteredData = filtered;
                renderTodayTable(filtered);
            }
        }
        
        function renderTodayTable(data) {
            const tbody = document.getElementById('todayTableBody');
            
            if (data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="no-results">No results found</td></tr>';
                return;
            }
            
            tbody.innerHTML = data.map(job => {
                // Determine job status: Pending, In Progress, Success, or Fail
                const isPending = !job.executionStartDate && job.executionSuccess === undefined;
                const isInProgress = job.executionStartDate && !job.executionFinishDate;
                const isSuccess = job.executionSuccess === true;
                const isFailed = job.executionSuccess === false;
                
                let statusText, statusClass;
                if (isPending) {
                    statusText = 'Pending';
                    statusClass = 'status-pending';
                } else if (isInProgress) {
                    statusText = 'In Progress';
                    statusClass = 'status-in-progress';
                } else if (isSuccess) {
                    statusText = 'Success';
                    statusClass = 'status-success';
                } else {
                    statusText = 'Fail';
                    statusClass = 'status-fail';
                }
                const startTime = job.executionStartDate ? formatTimeOnly(job.executionStartDate) : '-';
                const endTime = job.executionFinishDate ? formatTimeOnly(job.executionFinishDate) : '-';
                const bqData = job.bqTotalData !== undefined ? job.bqTotalData : '-';
                const savedData = job.analyticTotalData !== undefined ? job.analyticTotalData : '-';
                
                // Calculate duration
                const duration = job.executionStartDate && job.executionFinishDate 
                    ? calculateDuration(job.executionStartDate, job.executionFinishDate) 
                    : null;
                const durationDisplay = duration ? duration.formatted : '-';
                
                // Get time slots from matched job and highlight successful slot
                let timeSlotsDisplay = '<span style="color: var(--gray-400);">‚Äî</span>';
                // Use scheduledJob if available (from getTodayScheduledJobs), otherwise fall back to matchJobToScheduler
                const matchedJob = job.scheduledJob || matchJobToScheduler(job.analyticName);
                
                // Get frequency from matched job
                const frequency = matchedJob ? matchedJob.frequency || '-' : '-';
                
                // Get tab from matched job
                const tab = matchedJob ? (matchedJob.tab || '-') : '-';
                
                // Get environment badge - clean and compact styling
                const jobEnvironment = job.environment || getTodayJobEnvironment(matchedJob);
                let environmentBadge = '<span class="badge badge-secondary" style="padding: 0.2rem 0.6rem; border-radius: 0.375rem; font-size: 0.7rem; font-weight: 600; line-height: 1.2;">Unknown</span>';
                if (jobEnvironment === 'Canary') {
                    environmentBadge = '<span class="badge badge-warning" style="padding: 0.2rem 0.6rem; border-radius: 0.375rem; background: #fef3c7; color: #92400e; font-weight: 600; font-size: 0.7rem; display: inline-flex; align-items: center; gap: 0.3rem; line-height: 1.2; white-space: nowrap;">üü° Canary</span>';
                } else if (jobEnvironment === 'Non-Canary') {
                    environmentBadge = '<span class="badge badge-info" style="padding: 0.2rem 0.6rem; border-radius: 0.375rem; background: #dbeafe; color: #1e40af; font-weight: 600; font-size: 0.7rem; display: inline-flex; align-items: center; gap: 0.3rem; line-height: 1.2; white-space: nowrap;">üîµ Non-Canary</span>';
                }
                
                if (matchedJob) {
                    const hourString = matchedJob.hour || '0';
                    const hours = hourString.split(',').map(h => h.trim());
                    const scheduledMinute = parseInt(matchedJob.minute || '0');
                    
                    // Get actual start time to determine which slot was successful
                    let successSlotIndex = -1;
                    if (job.executionStartDate && job.executionSuccess) {
                        const startDate = new Date(parseInt(job.executionStartDate));
                        const startHour = startDate.getHours();
                        const startMinute = startDate.getMinutes();
                        const startTimeInMinutes = startHour * 60 + startMinute;
                        
                        // Find closest matching slot
                        let minDiff = Infinity;
                        hours.forEach((h, index) => {
                            const slotHour = parseInt(h);
                            const slotTimeInMinutes = slotHour * 60 + scheduledMinute;
                            const diff = Math.abs(startTimeInMinutes - slotTimeInMinutes);
                            
                            if (diff < 30 && diff < minDiff) {
                                minDiff = diff;
                                successSlotIndex = index;
                            }
                        });
                    }
                    
                    // Build time slots display with highlighting
                    if (hours.length > 1) {
                        timeSlotsDisplay = '<div style="display: flex; flex-direction: column; gap: 2px;">' + 
                            hours.map((h, index) => {
                                const slotTime = formatTime(h, matchedJob.minute || '0', matchedJob.seconds || '0');
                                const isSuccessSlot = index === successSlotIndex;
                                
                                if (isSuccessSlot) {
                                    return `<div style="background: #d1fae5; color: #065f46; padding: 2px 6px; border-radius: 3px; font-weight: 600; font-size: 0.75rem;">${slotTime} ‚úì</div>`;
                                } else {
                                    return `<div style="color: var(--gray-600); font-size: 0.75rem;">${slotTime}</div>`;
                                }
                            }).join('') + 
                        '</div>';
                    } else {
                        const slotTime = formatTime(matchedJob.hour || '0', matchedJob.minute || '0', matchedJob.seconds || '0');
                        if (job.executionSuccess) {
                            timeSlotsDisplay = `<div style="background: #d1fae5; color: #065f46; padding: 2px 6px; border-radius: 3px; font-weight: 600; font-size: 0.75rem; display: inline-block;">${slotTime} ‚úì</div>`;
                        } else {
                            timeSlotsDisplay = `<div style="color: var(--gray-600); font-size: 0.75rem;">${slotTime}</div>`;
                        }
                    }
                }
                
                // Check if BQ Data and Saved Data don't match
                const bqValue = toIntSafe(job.bqTotalData);
                const savedValue = toIntSafe(job.analyticTotalData);
                const hasMismatch = bqValue > 0 && savedValue > 0 && bqValue !== savedValue;
                const rowClass = hasMismatch ? 'data-mismatch' : '';
                
                // Check if this is a sales funnel scheduler and add validate button next to name
                const salesFunnelSchedulers = ['SALES_FUNNEL_YESTERDAY', 'SALES_FUNNEL_LAST_THIRTY_DAYS', 'SALES_FUNNEL_PREVIOUS_MONTH'];
                const isSalesFunnel = salesFunnelSchedulers.includes(job.analyticName);
                // Combine analytic name with tab (duration removed, will be in separate column)
                const tabDisplay = tab && tab !== '-' ? `<div style="color: var(--gray-600); font-size: 0.75rem; font-weight: 500;">Tab: <span style="color: var(--gray-900);">${tab}</span></div>` : '';
                const analyticNameWithTab = `<div style="display: flex; flex-direction: column; gap: 0.25rem;">
                    <div style="display: flex; align-items: center; flex-wrap: wrap;">
                        <span style="font-weight: 600; color: var(--gray-900);">${job.analyticName || ''}</span>
                        ${isSalesFunnel ? `<button onclick="showSalesFunnelValidationModal('${job.analyticName}')" 
                              style="margin-left: 0.5rem; padding: 0.1rem 0.4rem; background: var(--primary); color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.65rem; font-weight: 500;"
                              title="Validate Sales Funnel Report">
                          üîç
                       </button>` : ''}
                    </div>
                    ${tabDisplay}
                </div>`;
                
                // Combine start time and end time in a single column (without duration)
                const executionTimeDisplay = startTime !== '-' || endTime !== '-'
                    ? `<div style="display: flex; flex-direction: column; gap: 0.25rem; font-size: 0.875rem;">
                        ${startTime !== '-' ? `<div style="color: var(--gray-700);"><strong>Start:</strong> <span style="font-family: monospace; color: var(--gray-900);">${startTime}</span></div>` : ''}
                        ${endTime !== '-' ? `<div style="color: var(--gray-700);"><strong>End:</strong> <span style="font-family: monospace; color: var(--gray-900);">${endTime}</span></div>` : ''}
                    </div>`
                    : '-';
                
                // Combine Environment and Frequency in a single column
                const environmentFrequencyDisplay = `<div style="display: flex; flex-direction: column; gap: 0.25rem;">
                    ${environmentBadge}
                    <div style="color: var(--gray-700); font-size: 0.875rem;">${frequency}</div>
                </div>`;
                
                return `
                    <tr class="${rowClass}" data-duration="${duration ? duration.totalSeconds : 0}">
                        <td>${analyticNameWithTab}</td>
                        <td><span class="${statusClass}">${statusText}</span></td>
                        <td>${timeSlotsDisplay}</td>
                        <td>${executionTimeDisplay}</td>
                        <td data-sort-value="${duration ? duration.totalSeconds : 0}" style="color: var(--gray-700); font-size: 0.875rem;">${durationDisplay}</td>
                        <td>${bqData}</td>
                        <td>${savedData}</td>
                        <td>${environmentFrequencyDisplay}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Pattern Analysis Functions
        let patternData = [];
        let schedulerDurations = {};
        let patternCharts = {};
        let currentPatternSort = { column: 'time', direction: 'desc' };
        
        function matchJobToScheduler(schedulerName) {
            // First try: exact match on analyticName
            let matchedJob = JOBS_DATA.find(job => job.analyticName === schedulerName);
            
            if (matchedJob) return matchedJob;
            
            // Second try: case-insensitive match on analyticName
            matchedJob = JOBS_DATA.find(job => 
                job.analyticName.toUpperCase() === schedulerName.toUpperCase()
            );
            
            if (matchedJob) return matchedJob;
            
            // Third try: fuzzy matching on job name (fallback)
            const nameUpper = schedulerName.toUpperCase();
            matchedJob = JOBS_DATA.find(job => {
                const jobNameUpper = job.name.toUpperCase();
                const schedulerKey = nameUpper.replace(/_/g, '').replace(/\s+/g, '');
                const jobKey = jobNameUpper.replace(/SA_\d+_/g, '').replace(/_/g, '').replace(/\s+/g, '');
                return jobKey.includes(schedulerKey) || schedulerKey.includes(jobKey);
            });
            
            return matchedJob;
        }
        
        function determineAttemptStatusByTime(scheduler) {
            // Get all runs for this scheduler on this date, sorted by execution start time
            const runsOnDate = FILTERED_REPORTS_DATA.filter(s => 
                s.analyticName === scheduler.analyticName && 
                s.analyticDate === scheduler.analyticDate
            ).sort((a, b) => parseInt(a.executionStartDate || 0) - parseInt(b.executionStartDate || 0));
            
            if (runsOnDate.length === 0) return { status: 'Unknown', attempt: 1 };
            
            // Find position of current scheduler in the sorted list
            const currentIndex = runsOnDate.findIndex(r => r._id === scheduler._id);
            const attemptNumber = currentIndex + 1;
            
            // Check status
            const currentStatus = getStatus(scheduler);
            
            if (attemptNumber === 1) {
                return { 
                    status: currentStatus === 'success' ? 'First Try Success' : 'First Try Failed',
                    attempt: 1 
                };
            } else {
                // This is a retry
                if (currentStatus === 'success') {
                    return { status: `Retry Success (Attempt ${attemptNumber})`, attempt: attemptNumber };
                } else {
                    return { status: `Retry Failed (Attempt ${attemptNumber})`, attempt: attemptNumber };
                }
            }
        }
        
        function initPatternAnalysis() {
            // Calculate durations for each scheduler
            schedulerDurations = {};
            FILTERED_REPORTS_DATA.forEach(s => {
                const duration = calculateDuration(s.executionStartDate, s.executionFinishDate);
                if (duration && s.analyticName) {
                    if (!schedulerDurations[s.analyticName]) {
                        schedulerDurations[s.analyticName] = [];
                    }
                    schedulerDurations[s.analyticName].push(duration.totalSeconds);
                }
            });
            
            // Build pattern data with job matching and attempt detection
            patternData = FILTERED_REPORTS_DATA.map(scheduler => {
                const matchedJob = matchJobToScheduler(scheduler.analyticName);
                const attemptInfo = determineAttemptStatusByTime(scheduler);
                return {
                    ...scheduler,
                    matchedJob: matchedJob ? matchedJob.name : 'No Match',
                    jobRetry: matchedJob ? matchedJob.retry : '-',
                    attemptStatus: attemptInfo.status,
                    attemptNumber: attemptInfo.attempt
                };
            });
            
            // Update stats
            const totalSchedulers = new Set(FILTERED_REPORTS_DATA.map(s => s.analyticName)).size;
            const totalExecutions = FILTERED_REPORTS_DATA.length;
            const successfulExecutions = FILTERED_REPORTS_DATA.filter(s => getStatus(s) === 'success').length;
            const successRate = totalExecutions > 0 ? ((successfulExecutions / totalExecutions) * 100).toFixed(1) : 0;
            
            // Calculate peak hour
            const hourCounts = {};
            FILTERED_REPORTS_DATA.forEach(s => {
                if (s.executionStartDate) {
                    const hour = new Date(parseInt(s.executionStartDate)).getHours();
                    hourCounts[hour] = (hourCounts[hour] || 0) + 1;
                }
            });
            const peakHour = Object.keys(hourCounts).length > 0
                ? Object.keys(hourCounts).reduce((a, b) => hourCounts[a] > hourCounts[b] ? a : b)
                : '--';
            const peakHourFormatted = peakHour !== '--' ? `${peakHour.padStart(2, '0')}:00` : '--:--';
            const peakHourCount = peakHour !== '--' ? hourCounts[peakHour] : 0;
            
            // Update DOM (with null checks)
            const patternTotalSchedulers = document.getElementById('patternTotalSchedulers');
            const patternSchedulersTrend = document.getElementById('patternSchedulersTrend');
            const patternSuccessRate = document.getElementById('patternSuccessRate');
            const patternSuccessTrend = document.getElementById('patternSuccessTrend');
            const patternPeakHour = document.getElementById('patternPeakHour');
            const patternPeakTrend = document.getElementById('patternPeakTrend');
            
            if (patternTotalSchedulers) patternTotalSchedulers.textContent = totalSchedulers;
            if (patternSchedulersTrend) patternSchedulersTrend.textContent = `Unique jobs`;
            if (patternSuccessRate) patternSuccessRate.textContent = `${successRate}%`;
            if (patternSuccessTrend) patternSuccessTrend.textContent = `${successfulExecutions}/${totalExecutions} passed`;
            if (patternPeakHour) patternPeakHour.textContent = peakHourFormatted;
            if (patternPeakTrend) patternPeakTrend.textContent = peakHour !== '--' ? `${peakHourCount} executions` : `No data`;
            
            // Render visualizations
            renderDurationChart();
            renderHeatmap('All');
            renderPatternMatchTable(patternData);
        }
        
        function renderDurationChart() {
            const durationStats = Object.keys(schedulerDurations).map(name => {
                const durations = schedulerDurations[name];
                const avg = durations.reduce((sum, d) => sum + d, 0) / durations.length;
                return { name, avg };
            }).sort((a, b) => b.avg - a.avg);
            
            const maxDuration = Math.max(...durationStats.map(s => s.avg));
            
            let html = '<div style="padding: 20px;">';
            durationStats.forEach(stat => {
                const widthPct = (stat.avg / maxDuration) * 100;
                const minutes = Math.floor(stat.avg / 60);
                const seconds = Math.floor(stat.avg % 60);
                
                html += `
                    <div style="margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 3px; font-size: 12px;">
                            <span style="font-weight: 500;">${stat.name}</span>
                            <span style="color: #666;">${minutes}m ${seconds}s</span>
                        </div>
                        <div style="background: #e5e7eb; border-radius: 4px; height: 24px; position: relative;">
                            <div style="background: linear-gradient(90deg, #4f46e5, #6366f1); height: 100%; border-radius: 4px; width: ${widthPct}%; transition: width 0.3s;" title="${stat.name}: ${minutes}m ${seconds}s"></div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            const durationChart = document.getElementById('durationChart');
            if (durationChart) {
                durationChart.innerHTML = html;
            }
        }
        
        function renderAttemptChart() {
            const firstTry = patternData.filter(p => p.attemptStatus === 'First Try Success').length;
            const firstFail = patternData.filter(p => p.attemptStatus === 'First Try Failed').length;
            const retrySuccess = patternData.filter(p => p.attemptStatus.includes('Retry Success')).length;
            const retryFail = patternData.filter(p => p.attemptStatus.includes('Retry Failed')).length;
            
            const total = patternData.length;
            const data = [
                { label: 'First Try Success', count: firstTry, color: '#10b981', icon: '‚úì' },
                { label: 'First Try Failed', count: firstFail, color: '#ef4444', icon: '‚úó' },
                { label: 'Retry Success', count: retrySuccess, color: '#f59e0b', icon: '‚Üª' },
                { label: 'Retry Failed', count: retryFail, color: '#9ca3af', icon: '‚äó' }
            ];
            
            let html = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; padding: 20px;">';
            data.forEach(item => {
                const percentage = ((item.count / total) * 100).toFixed(1);
                html += `
                    <div style="background: white; border-left: 4px solid ${item.color}; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <div style="font-size: 28px; margin-bottom: 5px;">${item.icon}</div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 5px;">${item.label}</div>
                        <div style="font-size: 24px; font-weight: bold; color: ${item.color};">${item.count}</div>
                        <div style="font-size: 12px; color: #999;">${percentage}% of total</div>
                    </div>
                `;
            });
            html += '</div>';
            
            const attemptChart = document.getElementById('attemptChart');
            if (attemptChart) {
                attemptChart.innerHTML = html;
            }
        }
        
        function renderSuccessRateChart() {
            // Calculate success rate by scheduler
            const schedulerStats = {};
            patternData.forEach(p => {
                if (!schedulerStats[p.analyticName]) {
                    schedulerStats[p.analyticName] = { success: 0, total: 0 };
                }
                schedulerStats[p.analyticName].total++;
                if (p.attemptStatus.includes('Success')) {
                    schedulerStats[p.analyticName].success++;
                }
            });
            
            const successRates = Object.keys(schedulerStats).map(name => ({
                name,
                rate: (schedulerStats[name].success / schedulerStats[name].total) * 100,
                total: schedulerStats[name].total
            })).sort((a, b) => b.total - a.total).slice(0, 15);
            
            const ctx = document.getElementById('successRateChart').getContext('2d');
            if (patternCharts.successRate) patternCharts.successRate.destroy();
            
            patternCharts.successRate = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: successRates.map(s => s.name.length > 25 ? s.name.substring(0, 25) + '...' : s.name),
                    datasets: [{
                        label: 'Success Rate (%)',
                        data: successRates.map(s => s.rate),
                        backgroundColor: successRates.map(s => s.rate >= 90 ? 'rgba(16, 185, 129, 0.8)' : s.rate >= 70 ? 'rgba(245, 158, 11, 0.8)' : 'rgba(239, 68, 68, 0.8)'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => `Success Rate: ${ctx.parsed.y.toFixed(1)}% (${successRates[ctx.dataIndex].total} runs)`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: (value) => value + '%'
                            }
                        }
                    }
                }
            });
        }
        
        let currentHeatmapFrequency = 'All';
        
        function filterHeatmap(frequency) {
            currentHeatmapFrequency = frequency;
            
            // Update button styles
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.style.background = 'white';
                btn.style.color = 'var(--gray-700)';
            });
            const activeBtn = document.getElementById(`heatmap-${frequency.toLowerCase()}`);
            if (activeBtn) {
                activeBtn.style.background = 'var(--primary)';
                activeBtn.style.color = 'white';
            }
            
            // Re-render heatmap with filter
            renderHeatmap(frequency);
        }
        
        function renderHeatmap(frequencyFilter = 'All') {
            // Filter pattern data by frequency
            let filteredData = patternData;
            if (frequencyFilter !== 'All') {
                filteredData = patternData.filter(p => {
                    const matchedJob = matchJobToScheduler(p.analyticName);
                    return matchedJob && matchedJob.frequency === frequencyFilter;
                });
            }
            
            if (filteredData.length === 0) {
                document.getElementById('heatmapContainer').innerHTML = 
                    `<div class="no-results">No ${frequencyFilter} schedulers found</div>`;
                return;
            }
            
            // Group schedulers by hour of day
            const schedulersByHour = {};
            
            // Get all schedulers sorted by frequency
            const schedulerCounts = {};
            filteredData.forEach(p => {
                schedulerCounts[p.analyticName] = (schedulerCounts[p.analyticName] || 0) + 1;
            });
            const topSchedulers = Object.keys(schedulerCounts)
                .sort((a, b) => schedulerCounts[b] - schedulerCounts[a]);
            
            topSchedulers.forEach(scheduler => {
                schedulersByHour[scheduler] = Array(24).fill(null).map(() => ({ success: 0, retry: 0, failed: 0 }));
            });
            
            filteredData.filter(p => topSchedulers.includes(p.analyticName)).forEach(p => {
                if (p.executionStartDate) {
                    const hour = new Date(parseInt(p.executionStartDate)).getHours();
                    if (p.attemptStatus === 'First Try Success') {
                        schedulersByHour[p.analyticName][hour].success++;
                    } else if (p.attemptStatus.includes('Retry')) {
                        schedulersByHour[p.analyticName][hour].retry++;
                    } else {
                        schedulersByHour[p.analyticName][hour].failed++;
                    }
                }
            });
            
            // Render heatmap
            let html = '<div class="heatmap-grid">';
            
            // Header row with hours - make it sticky
            html += '<div class="heatmap-row heatmap-row-header">';
            html += '<div class="heatmap-label">Scheduler</div>';
            for (let h = 0; h < 24; h++) {
                html += `<div class="heatmap-label" style="text-align: center;">${h.toString().padStart(2, '0')}</div>`;
            }
            html += '</div>';
            
            // Data rows
            topSchedulers.forEach(scheduler => {
                html += '<div class="heatmap-row">';
                html += `<div class="heatmap-label" style="font-size: 0.7rem;">${scheduler.length > 25 ? scheduler.substring(0, 25) + '...' : scheduler}</div>`;
                
                // Get scheduled time slots from Rundeck Jobs
                const matchedJob = matchJobToScheduler(scheduler);
                const scheduledSlots = [];
                if (matchedJob) {
                    const hourString = matchedJob.hour || '0';
                    const minute = matchedJob.minute || '0';
                    const seconds = matchedJob.seconds || '0';
                    const hours = hourString.split(',').map(h => parseInt(h.trim()));
                    
                    hours.forEach(hour => {
                        const timeStr = formatTime(hour.toString(), minute, seconds);
                        scheduledSlots.push({
                            hour: hour,
                            time: timeStr
                        });
                    });
                }
                
                for (let h = 0; h < 24; h++) {
                    const data = schedulersByHour[scheduler][h];
                    const total = data.success + data.retry + data.failed;
                    
                    // Check if this hour is a scheduled time slot
                    const scheduledSlot = scheduledSlots.find(slot => slot.hour === h);
                    const isScheduled = scheduledSlot !== undefined;
                    
                    // Build tooltip with scheduled time info
                    let tooltip = `${scheduler} at ${h}:00`;
                    if (isScheduled) {
                        tooltip += `\nüìÖ Scheduled: ${scheduledSlot.time}`;
                        // If there are multiple scheduled slots, show all of them
                        if (scheduledSlots.length > 1) {
                            const allScheduledTimes = scheduledSlots.map(s => s.time).join(', ');
                            tooltip += `\nAll scheduled times: ${allScheduledTimes}`;
                        }
                    } else if (scheduledSlots.length > 0) {
                        // Show all scheduled times even if this hour is not scheduled
                        const allScheduledTimes = scheduledSlots.map(s => s.time).join(', ');
                        tooltip += `\nüìÖ Scheduled times: ${allScheduledTimes}`;
                    }
                    if (total > 0) {
                        tooltip += `\nSuccess: ${data.success}, Retry: ${data.retry}, Failed: ${data.failed}`;
                    }
                    
                    if (total === 0) {
                        // No activity - show scheduled slot with border if it's scheduled
                        if (isScheduled) {
                            html += `<div class="heatmap-cell empty" style="border: 2px solid #3b82f6; border-style: dashed;" 
                                     title="${tooltip}">üìÖ</div>`;
                        } else {
                            html += `<div class="heatmap-cell empty" title="${tooltip}"></div>`;
                        }
                    } else {
                        let bgColor = '#10b981'; // green
                        if (data.failed > 0) bgColor = '#ef4444'; // red
                        else if (data.retry > 0) bgColor = '#f59e0b'; // orange
                        
                        const opacity = 0.3 + (Math.min(total, 10) / 10) * 0.7;
                        // Add border for scheduled slots
                        const borderStyle = isScheduled ? 'border: 2px solid #1e40af;' : '';
                        // Add click handler and cursor pointer for cells with activity
                        const escapedScheduler = scheduler.replace(/'/g, "\\'");
                        html += `<div class="heatmap-cell" style="background: ${bgColor}; opacity: ${opacity}; ${borderStyle}; cursor: pointer;" 
                                 onclick="showSchedulerRunsModal('${escapedScheduler}', ${h})"
                                 title="${tooltip}\n\nClick to view run details">${total}</div>`;
                    }
                }
                html += '</div>';
            });
            
            html += '</div>';
            document.getElementById('heatmapContainer').innerHTML = html;
        }
        
        function populateTimelineDates() {
            const select = document.getElementById('timelineDate');
            const dates = [...new Set(FILTERED_REPORTS_DATA.map(s => s.analyticDate))].sort((a, b) => parseInt(b) - parseInt(a));
            select.innerHTML = '<option value="">Select a date...</option>' + 
                dates.map(d => `<option value="${d}">${formatDate(d)}</option>`).join('');
        }
        
        function toggleTimeline() {
            const timelineSection = document.getElementById('timelineSection');
            const timelineContent = document.getElementById('timelineContent');
            
            if (timelineContent.style.display === 'none') {
                timelineContent.style.display = 'block';
                timelineSection.querySelector('button').innerHTML = '√ó';
                timelineSection.querySelector('button').title = 'Close';
            } else {
                timelineContent.style.display = 'none';
                timelineSection.querySelector('button').innerHTML = '+';
                timelineSection.querySelector('button').title = 'Open';
            }
        }
        
        function renderTimeline() {
            const selectedDate = document.getElementById('timelineDate').value;
            const container = document.getElementById('timelineContainer');
            
            if (!selectedDate) {
                container.innerHTML = '<div class="no-results" style="padding: 1.5rem;">Select a date to view execution timeline</div>';
                return;
            }
            
            // Get all runs for this date
            const runsOnDate = patternData.filter(p => p.analyticDate === selectedDate);
            
            // Group by scheduler
            const schedulerRuns = {};
            runsOnDate.forEach(run => {
                if (!schedulerRuns[run.analyticName]) {
                    schedulerRuns[run.analyticName] = [];
                }
                schedulerRuns[run.analyticName].push(run);
            });
            
            // Render timeline
            let html = '<div class="timeline-container" style="padding: 1.5rem;">';
            
            // Hour labels
            html += '<div class="timeline-hours" style="padding-left: 200px;">';
            for (let h = 0; h < 24; h++) {
                html += `<div class="timeline-hour">${h.toString().padStart(2, '0')}:00</div>`;
            }
            html += '</div>';
            
            // Timeline rows - now using Rundeck job scheduled times
            Object.keys(schedulerRuns).sort().forEach(schedulerName => {
                const matchedJob = matchJobToScheduler(schedulerName);
                
                html += '<div class="timeline-row">';
                html += `<div class="timeline-label" title="${schedulerName}">${schedulerName.length > 25 ? schedulerName.substring(0, 25) + '...' : schedulerName}</div>`;
                html += '<div class="timeline-track">';
                
                if (matchedJob) {
                    // Get scheduled time slots from Rundeck job
                    const hours = matchedJob.hour ? matchedJob.hour.split(',').map(h => h.trim()) : [];
                    const minutes = matchedJob.minute ? matchedJob.minute.split(',').map(m => m.trim()) : ['0'];
                    
                    // For each scheduled time slot
                    hours.forEach(hour => {
                        minutes.forEach(minute => {
                            const schedHour = parseInt(hour);
                            const schedMinute = parseInt(minute);
                            const leftPercent = ((schedHour * 60 + schedMinute) / (24 * 60)) * 100;
                            
                            // Find execution at this time slot (within 5 minute window)
                            const execution = schedulerRuns[schedulerName].find(run => {
                                if (run.executionStartDate) {
                                    const startDate = new Date(parseInt(run.executionStartDate));
                                    const runHour = startDate.getHours();
                                    const runMinute = startDate.getMinutes();
                                    // Check if run time is within 5 minutes of scheduled time
                                    return Math.abs(runHour - schedHour) === 0 && 
                                           Math.abs(runMinute - schedMinute) <= 5;
                                }
                                return false;
                            });
                            
                            let statusClass = 'pending';
                            let title = `${schedulerName}\nScheduled: ${hour.padStart(2, '0')}:${minute.padStart(2, '0')}`;
                            let label = '‚è±';
                            
                            if (execution) {
                                const duration = calculateDuration(execution.executionStartDate, execution.executionFinishDate);
                                statusClass = execution.attemptStatus.includes('Success') ? 'success' : 
                                            execution.attemptStatus.includes('Retry') ? 'retry' : 'failed';
                                title = `${schedulerName}\nScheduled: ${hour.padStart(2, '0')}:${minute.padStart(2, '0')}\nActual: ${formatDateTime(execution.executionStartDate)}\n${execution.attemptStatus}\nDuration: ${duration ? formatDuration(duration) : 'N/A'}`;
                                label = execution.attemptNumber;
                            }
                            
                            html += `<div class="timeline-event ${statusClass}" 
                                     style="left: ${leftPercent}%; width: 0.8%;"
                                     title="${title}">
                                     ${label}
                                     </div>`;
                        });
                    });
                } else {
                    // No matched job - show actual executions
                    schedulerRuns[schedulerName].sort((a, b) => 
                        parseInt(a.executionStartDate || 0) - parseInt(b.executionStartDate || 0)
                    ).forEach(run => {
                        if (run.executionStartDate) {
                            const startDate = new Date(parseInt(run.executionStartDate));
                            const hour = startDate.getHours();
                            const minute = startDate.getMinutes();
                            const leftPercent = ((hour * 60 + minute) / (24 * 60)) * 100;
                            
                            const duration = calculateDuration(run.executionStartDate, run.executionFinishDate);
                            const statusClass = run.attemptStatus.includes('Success') ? 'success' : 
                                              run.attemptStatus.includes('Retry') ? 'retry' : 'failed';
                            
                            html += `<div class="timeline-event ${statusClass}" 
                                     style="left: ${leftPercent}%; width: 0.8%;"
                                     title="${schedulerName}\nStart: ${formatDateTime(run.executionStartDate)}\n${run.attemptStatus}\nDuration: ${duration ? formatDuration(duration) : 'N/A'}">
                                     ${run.attemptNumber}
                                     </div>`;
                        }
                    });
                }
                
                html += '</div></div>';
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function sortPatternTable(column) {
            if (currentPatternSort.column === column) {
                currentPatternSort.direction = currentPatternSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentPatternSort.column = column;
                currentPatternSort.direction = 'desc';
            }
            
            // Get currently filtered data
            const searchTerm = document.getElementById('patternSearchInput').value.toLowerCase();
            const selectedDate = document.getElementById('patternDateFilter').value;
            
            let dataToSort = [...patternData];
            
            // Apply filters before sorting
            if (searchTerm) {
                dataToSort = dataToSort.filter(item => 
                    item.analyticName.toLowerCase().includes(searchTerm)
                );
            }
            if (selectedDate) {
                dataToSort = dataToSort.filter(item => item.analyticDate === selectedDate);
            }
            
            const sorted = dataToSort.sort((a, b) => {
                let valA, valB;
                switch (column) {
                    case 'analyticName':
                        valA = a.analyticName || '';
                        valB = b.analyticName || '';
                        break;
                    case 'date':
                        valA = parseInt(a.analyticDate || 0);
                        valB = parseInt(b.analyticDate || 0);
                        break;
                    case 'timeSlot':
                        // Sort by first scheduled time slot
                        const jobA = matchJobToScheduler(a.analyticName);
                        const jobB = matchJobToScheduler(b.analyticName);
                        valA = jobA && jobA.hour ? parseInt(jobA.hour.split(',')[0]) * 60 + parseInt(jobA.minute ? jobA.minute.split(',')[0] : 0) : 9999;
                        valB = jobB && jobB.hour ? parseInt(jobB.hour.split(',')[0]) * 60 + parseInt(jobB.minute ? jobB.minute.split(',')[0] : 0) : 9999;
                        break;
                    case 'successSlot':
                        // Sort by success time
                        const successA = FILTERED_REPORTS_DATA.find(s => s.analyticName === a.analyticName && s.analyticDate === a.analyticDate && getStatus(s) === 'success');
                        const successB = FILTERED_REPORTS_DATA.find(s => s.analyticName === b.analyticName && s.analyticDate === b.analyticDate && getStatus(s) === 'success');
                        valA = successA && successA.executionStartDate ? parseInt(successA.executionStartDate) : 0;
                        valB = successB && successB.executionStartDate ? parseInt(successB.executionStartDate) : 0;
                        break;
                    case 'status':
                        valA = a.attemptStatus || '';
                        valB = b.attemptStatus || '';
                        break;
                    case 'duration':
                        const durA = calculateDuration(a.executionStartDate, a.executionFinishDate);
                        const durB = calculateDuration(b.executionStartDate, b.executionFinishDate);
                        valA = durA ? durA.totalSeconds : 0;
                        valB = durB ? durB.totalSeconds : 0;
                        break;
                    case 'data':
                        valA = parseInt(a.analyticTotalData || 0);
                        valB = parseInt(b.analyticTotalData || 0);
                        break;
                    default:
                        return 0;
                }
                
                if (typeof valA === 'string') {
                    return currentPatternSort.direction === 'asc' 
                        ? valA.localeCompare(valB) 
                        : valB.localeCompare(valA);
                } else {
                    return currentPatternSort.direction === 'asc' 
                        ? valA - valB 
                        : valB - valA;
                }
            });
            
            renderPatternMatchTable(sorted);
        }
        
        function renderPatternMatchTable(data = patternData) {
            const tbody = document.getElementById('patternMatchBody');
            if (!tbody) return; // Element doesn't exist, skip
            
            if (data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="no-results">No data to display</td></tr>';
                return;
            }
            
            tbody.innerHTML = data.map(scheduler => {
                const matchedJob = matchJobToScheduler(scheduler.analyticName);
                const duration = calculateDuration(scheduler.executionStartDate, scheduler.executionFinishDate);
                const status = getStatus(scheduler);
                
                // Get scheduled time slots from Rundeck job - display similar to Rundeck Jobs table
                let timeSlotsDisplay = '<span style="color: var(--gray-400);">‚Äî</span>';
                if (matchedJob) {
                    const hourString = matchedJob.hour || '0';
                    const hours = hourString.split(',').map(h => h.trim());
                    const minute = matchedJob.minute || '0';
                    
                    if (hours.length > 1) {
                        // Multiple scheduled times - show on separate lines like in Rundeck Jobs table
                        timeSlotsDisplay = `<div>${hours.map(h => formatTime(h, minute, matchedJob.seconds || '0')).join('<br>')}</div>`;
                    } else {
                        // Single scheduled time
                        timeSlotsDisplay = `<span class="schedule-time">${formatTime(matchedJob.hour || '0', minute, matchedJob.seconds || '0')}</span>`;
                    }
                }
                
                // Get success time slot - find when this scheduler succeeded for this date
                let successTimeSlot = '<span style="color: var(--gray-400);">‚Äî</span>';
                const successRun = FILTERED_REPORTS_DATA.find(s => 
                    s.analyticName === scheduler.analyticName && 
                    s.analyticDate === scheduler.analyticDate && 
                    getStatus(s) === 'success'
                );
                
                if (successRun && successRun.executionStartDate && matchedJob) {
                    const successDate = new Date(parseInt(successRun.executionStartDate));
                    const successHour = successDate.getHours();
                    const successMinute = successDate.getMinutes();
                    const successHourStr = successHour.toString().padStart(2, '0');
                    const successMinuteStr = successMinute.toString().padStart(2, '0');
                    
                    // Determine which slot this success time corresponds to
                    let slotLabel = '';
                    const hourString = matchedJob.hour || '0';
                    const hours = hourString.split(',').map(h => h.trim());
                    const scheduledMinute = parseInt(matchedJob.minute || '0');
                    
                    if (hours.length > 1) {
                        // Multiple slots - find which one
                        const successTimeInMinutes = successHour * 60 + successMinute;
                        let closestSlotIndex = -1;
                        let minDiff = Infinity;
                        
                        hours.forEach((h, index) => {
                            const slotHour = parseInt(h);
                            const slotTimeInMinutes = slotHour * 60 + scheduledMinute;
                            const diff = Math.abs(successTimeInMinutes - slotTimeInMinutes);
                            
                            // Consider within 30 minutes of scheduled time as matching that slot
                            if (diff < 30 && diff < minDiff) {
                                minDiff = diff;
                                closestSlotIndex = index;
                            }
                        });
                        
                        if (closestSlotIndex !== -1) {
                            const slotNumber = closestSlotIndex + 1;
                            const totalSlots = hours.length;
                            
                            // Determine ordinal suffix
                            let suffix = 'th';
                            if (slotNumber === 1) suffix = 'st';
                            else if (slotNumber === 2) suffix = 'nd';
                            else if (slotNumber === 3) suffix = 'rd';
                            
                            // Check if it's the last slot
                            if (slotNumber === totalSlots) {
                                slotLabel = `<div style="font-size: 0.7rem; color: var(--gray-600); margin-top: 2px;">${slotNumber}${suffix} / Last slot</div>`;
                            } else {
                                slotLabel = `<div style="font-size: 0.7rem; color: var(--gray-600); margin-top: 2px;">${slotNumber}${suffix} slot</div>`;
                            }
                        }
                    } else {
                        // Single slot - just mention it's the only slot
                        slotLabel = `<div style="font-size: 0.7rem; color: var(--gray-600); margin-top: 2px;">Only slot</div>`;
                    }
                    
                    successTimeSlot = `<div><span class="badge badge-success">${successHourStr}:${successMinuteStr}</span>${slotLabel}</div>`;
                }
                
                return `
                    <tr>
                        <td><strong>${scheduler.analyticName}</strong></td>
                        <td>${formatDate(scheduler.analyticDate)}</td>
                        <td>${timeSlotsDisplay}</td>
                        <td>${successTimeSlot}</td>
                        <td><span class="badge badge-${status}">${status}</span></td>
                        <td>${duration ? duration.formatted : 'N/A'}</td>
                        <td>${scheduler.analyticTotalData ? parseInt(scheduler.analyticTotalData).toLocaleString() : 'N/A'}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Filter pattern match table with both search and date
        function filterPatternTable() {
            const patternSearchInput = document.getElementById('patternSearchInput');
            const patternDateFilter = document.getElementById('patternDateFilter');
            
            if (!patternSearchInput || !patternDateFilter) return; // Elements don't exist, skip
            
            const searchTerm = patternSearchInput.value.toLowerCase();
            const selectedDate = patternDateFilter.value;
            
            let filtered = patternData;
            
            // Apply search filter
            if (searchTerm) {
                filtered = filtered.filter(item => 
                    item.analyticName.toLowerCase().includes(searchTerm)
                );
            }
            
            // Apply date filter
            if (selectedDate) {
                filtered = filtered.filter(item => item.analyticDate === selectedDate);
            }
            
            renderPatternMatchTable(filtered);
        }
        
        // Search for pattern match table
        function searchPatternMatch() {
            filterPatternTable();
        }
        
        // Populate date filter for pattern analysis
        function populatePatternDateFilter() {
            const select = document.getElementById('patternDateFilter');
            if (!select) return; // Element doesn't exist, skip
            
            // Clear existing options except "All Dates"
            select.innerHTML = '<option value="">All Dates</option>';
            
            const dates = [...new Set(FILTERED_REPORTS_DATA.map(s => s.analyticDate))].sort((a, b) => parseInt(b) - parseInt(a));
            dates.forEach(date => {
                const opt = document.createElement('option');
                opt.value = date;
                opt.textContent = formatDate(date);
                select.appendChild(opt);
            });
        }
        
        // Initialize
        function init() {
            // Set initial reports header visibility based on active page
            const reportsHeader = document.getElementById('reportsHeader');
            const isReportsOverview = document.getElementById('reports-overview-section')?.classList.contains('active');
            const isReportsPatterns = document.getElementById('reports-patterns-section')?.classList.contains('active');
            const isReportsData = document.getElementById('reports-data-section')?.classList.contains('active');
            const isReportsPage = isReportsOverview || isReportsPatterns || isReportsData;
            
            if (reportsHeader) {
                reportsHeader.style.display = isReportsPage ? 'block' : 'none';
            }
            
            // Load last updated time for reports pages
            if (isReportsPage) {
                loadPastDataLastUpdatedTime();
            }
            
            // Set initial refresh button visibility based on active page
            const refreshBtn = document.getElementById('refreshDataBtn');
            if (refreshBtn) {
                const isTodayReport = document.getElementById('today-report-section')?.classList.contains('active');
                
                if (isTodayReport) {
                    refreshBtn.style.display = 'inline-flex';
                    const refreshText = document.getElementById('refreshText');
                    if (refreshText) {
                        refreshText.textContent = 'Refresh today data';
                    }
                    // Show refresh button container
                    const refreshContainer = document.getElementById('refreshButtonContainer');
                    if (refreshContainer) {
                        refreshContainer.style.display = 'flex';
                    }
                    // Load last updated time for Today's Report page
                    loadLastUpdatedTime(true);
                } else {
                    refreshBtn.style.display = 'none';
                    // Hide refresh button container on other pages
                    const refreshContainer = document.getElementById('refreshButtonContainer');
                    if (refreshContainer) {
                        refreshContainer.style.display = 'none';
                    }
                }
            }
            
            // Jobs
            populateTabFilter();
            updateJobsStats();
            renderJobsTable();
            renderJobsHeatmap(currentJobsHeatmapTryFilter, currentJobsHeatmapStatusFilter, currentJobsHeatmapEnvironmentFilter);
            
            // Add search event listener for pattern analysis
            const patternSearch = document.getElementById('patternSearchInput');
            if (patternSearch) {
                patternSearch.addEventListener('input', searchPatternMatch);
            }
            
            // Today's Report
            initTodayReport();
            
            // Reports - Initialize filtered data first
            FILTERED_REPORTS_DATA = getFilteredReportsData();
            displayReportsDateRange();
            renderDailyBreakdownChart();
            
            // Pattern Analysis
            initPatternAnalysis();
            populatePatternDateFilter();
        }
        
        // Initialize on DOM load
        document.addEventListener('DOMContentLoaded', async function() {
            // Load data from external JSON files first
            const dataLoaded = await loadData();
            
            if (!dataLoaded) {
                console.error('Failed to load data. Dashboard cannot initialize.');
                return;
            }
            
            // Initialize dashboard after data is loaded
            init();
            
            // Event Listeners
            const jobSearchInput = document.getElementById('jobSearch');
            jobSearchInput.addEventListener('input', function() {
                updateSearchClearButton('jobSearch');
                renderJobsTable();
            });
            document.getElementById('frequencyFilter').addEventListener('change', renderJobsTable);
            document.getElementById('jobStatusFilter').addEventListener('change', renderJobsTable);
            document.getElementById('environmentFilter').addEventListener('change', renderJobsTable);
            const tabFilterEl = document.getElementById('tabFilter');
            if (tabFilterEl) {
                tabFilterEl.addEventListener('change', renderJobsTable);
            }
            
            document.querySelectorAll('#jobs-section th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const field = th.dataset.sort;
                    if (jobSort.field === field) {
                        jobSort.direction = jobSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        jobSort.field = field;
                        jobSort.direction = 'asc';
                    }
                    renderJobsTable();
                    
                    // Update sort indicators
                    document.querySelectorAll('#jobs-section th').forEach(t => t.classList.remove('sort-asc', 'sort-desc'));
                    th.classList.add(`sort-${jobSort.direction}`);
                });
            });
            
            document.getElementById('patternSearchInput').addEventListener('input', searchPatternMatch);
            
            window.onclick = (event) => {
                const modal = document.getElementById('curlModal');
                if (event.target === modal) closeModal();
                const bqModal = document.getElementById('bqDetailsModal');
                if (event.target === bqModal) closeBqDetailsModal();
                const schedulerRunsModal = document.getElementById('schedulerRunsModal');
                if (event.target === schedulerRunsModal) closeSchedulerRunsModal();
                const salesFunnelModal = document.getElementById('salesFunnelValidationModal');
                if (event.target === salesFunnelModal) closeSalesFunnelValidationModal();
            };
        });
    </script>
</body>
</html>

